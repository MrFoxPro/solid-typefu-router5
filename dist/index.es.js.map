{"version":3,"file":"index.es.js","sources":["../src/context.ts","../src/components/Link.tsx","../src/components/MatchRoute.tsx","../src/components/RouteTree.tsx","../src/index.tsx"],"sourcesContent":["import { createContext, useContext, createMemo } from 'solid-js';\nimport { RouterContextValue } from './types';\nimport { State as RouteState } from 'router5';\nimport { RouteLike } from 'components/Link';\n\nconst Context = createContext<RouterContextValue>();\n\nexport default Context;\n\nexport function useRoute(): () => RouteState {\n  return useContext(Context).getRoute;\n}\n\nexport function useRouteName(): () => string[] {\n  return useContext(Context).getRouteName;\n}\n\nexport function useRouteNameRaw(): () => string {\n  return useContext(Context).getRouteNameRaw;\n}\n\nexport function useActive<Link extends RouteLike>(link: Link): () => boolean {\n  const getRouteName = useRouteName();\n  return createMemo(() => isActive(getRouteName(), link));\n}\n\n/**\n * Find whether 'link' is an ancestor of, or equal to, 'here'\n */\nexport function isActive<Route extends RouteLike>(here: string[], link: Route) {\n  if (here.length === 0) { return false; }\n  if (typeof link === 'string') { return here[0] === link; }\n  // if link has more segments than here then it definitely cannot be an\n  // ancestor of here\n  if (link.length > here.length) return false;\n  for (let i = 0; i < link.length; i ++) {\n    if (link[i] !== here[i]) return false;\n  }\n  return true;\n}\n","import { SharedRouterValue, RoutesLike } from '../types';\nimport { isActive, useRouteName } from '../context';\nimport { createMemo } from 'solid-js';\n\nexport enum LinkNav { Back, Forward };\n\n/** Props for making a `Link`\n *\n * @remarks\n *\n * Only some of the props are reactive; the rest are static at the time of\n * creating the link. The reactive props available are:\n *\n * - `to`\n * - `params`\n * - `disabled`\n * - `onClick`\n * - `innerProps`\n * - `disabledProps`\n */\nexport type LinkProps<Route> = {\n  disabled?: boolean,\n  nav?: boolean,\n  onClick?: (ev: MouseEvent & {\n    target: HTMLAnchorElement,\n    currentTarget: HTMLAnchorElement,\n  }) => void,\n} & ({\n  type: LinkNav.Back | LinkNav.Forward\n} | {\n  type?: undefined,\n  to: Route,\n  params?: Record<string, any>,\n}) &\n  Omit<JSX.IntrinsicElements['a' | 'button'], 'onClick' | 'href' | 'type'>\n  ;\n\nexport interface LinkConfig {\n  navActiveClassName: string,\n}\n\nexport type RouteLike = string | string[];\n\nexport function renderRouteLike(route: RouteLike) {\n  if (typeof route === 'string') return route;\n  return route.join('.');\n}\n\nexport const defaultLinkConfig: LinkConfig = {\n  navActiveClassName: 'is-active',\n};\n\nexport default function createLink<Deps, Routes extends RoutesLike<Deps>, RouteName extends RouteNameOf<Routes> & RouteLike>(\n  self: SharedRouterValue<Deps, Routes>,\n  config: Partial<LinkConfig> = defaultLinkConfig,\n): (props: LinkProps<RouteName>) => JSX.Element {\n\n  const { router5 } = self;\n\n  const {\n    navActiveClassName = defaultLinkConfig.navActiveClassName,\n  } = config;\n\n  return (props: LinkProps<RouteName>): JSX.Element => {\n\n    const getRouteName = useRouteName();\n\n    const getClassList = createMemo(() => {\n      const classList = props.classList ?? {};\n      if (props.type === undefined && props.nav) {\n        classList[navActiveClassName] = isActive(getRouteName(), props.to as RouteLike);\n        return classList;\n      }\n      return classList;\n    });\n\n    const getInnerProps = createMemo(() => {\n      const {classList: _cl, onClick: _oc, ...innerProps} = props;\n      return innerProps;\n    });\n\n    const getHref: () => string | undefined = createMemo(() => {\n      if (props.type === undefined) {\n        try {\n          return router5.buildPath(renderRouteLike(props.to), props.params);\n        } catch (err) {\n          console.warn('<Link> buildPath failed:', err);\n        }\n      }\n      return undefined;\n    });\n\n    return () => props.disabled ?\n      <button\n        {...getInnerProps() as JSX.IntrinsicElements['button']}\n        disabled\n        classList={getClassList()}\n      /> :\n      <a\n        {...getInnerProps() as JSX.IntrinsicElements['a']}\n        classList={getClassList()}\n        href={getHref()}\n        onClick={(ev) => {\n          ev.preventDefault();\n          switch (props.type) {\n            case undefined:\n              router5.navigate(renderRouteLike(props.to as RouteLike), props.params ?? {});\n              if (typeof props.onClick === 'function') props.onClick(ev);\n              break;\n            case LinkNav.Back:\n              window.history.back();\n              break;\n            case LinkNav.Back:\n              window.history.back();\n              break;\n          }\n          ev.target.blur();\n        }}\n      />;\n  };\n}\n\n// Beware, here be dragons\nexport type RouteNameOf<A> = UnOne<Undefer<Flatten<TreeOf<A>, []>>>;\n\ntype TreeOf<A> =\n  A extends readonly (infer U)[]\n    ? U extends { name: infer Name, children: infer Children }\n      ? Children extends {}\n        ? [Name] | [Name, TreeOf<Children>]\n        : Name\n    : U extends { name: infer Name }\n      ? [Name]\n      : never\n  : never;\n\ntype UnOne<A> = A extends [infer U] ? U : A;\n\n// This is what requires typescript 4.0+\ntype Flatten<Arg, Acc extends any[]> =\n  Arg extends [infer X]\n  ? [...Acc, X]\n  : Arg extends [infer X, infer XS]\n    ? Defer<Flatten<XS, [...Acc, X]>>\n    : never;\n\n// Same trick as in https://github.com/microsoft/TypeScript/pull/21613\ninterface Defer<X> { self: Undefer<X> }\ntype Undefer<X> = X extends { self: infer U } ? U : X;\n","import { createContext, useContext, Match, Show, createMemo } from \"solid-js\";\nimport { useRouteNameRaw } from '../context';\n\nconst MatchContext = createContext<string>('');\n\n/**\n * If `path` is given, then the match is exact, which means that the current\n * route name must be equal to `context.path + path` where `context.path` means\n * the current path created by other match components above this one.\n *\n * If `prefix` is given, then the match only requires that the current route\n * start with `context.path + prefix`.\n */\nexport type MatchRouteProps =\n  PathProps & { children: JSX.Element };\n\nexport type PathProps =\n  {\n    prefix: string,\n    path?: undefined,\n  } | {\n    prefix?: undefined,\n    path: string,\n  };\n\nfunction doesMatch(ctx: string, here: string, props: PathProps): [string, boolean] {\n  const suffix = props.path !== undefined ? props.path : props.prefix;\n  const exact = props.path !== undefined;\n  const target = ctx !== '' ? `${ctx}.${suffix}` : suffix;\n  return [\n    target,\n    exact ? here === target : here.startsWith(target),\n  ];\n}\n\nfunction createGetMatch(props: PathProps): () => [string, boolean] {\n  const route = useRouteNameRaw();\n  const ctx = useContext(MatchContext);\n  return createMemo<[string, boolean]>(\n    () => doesMatch(ctx, route(), props),\n    undefined,\n    (a, b) => a && a[1] === b[1],\n  );\n}\n\n/**\n * Match against a given route.\n *\n * @remarks\n * Not reactive with regards to the route being matched.\n */\nexport function MatchRoute(props: MatchRouteProps): JSX.Element {\n  const getMatch = createGetMatch(props);\n  return (\n    <Match when={getMatch()[1]}>\n      <MatchContext.Provider value={getMatch()[0]}>\n        {props.children}\n      </MatchContext.Provider>\n    </Match>);\n}\n\n/**\n * Not reactive on the routes being used\n */\nexport function SwitchRoutes(props: {\n  children: MatchRouteProps[]\n  fallback?: JSX.Element,\n}): JSX.Element {\n  const ctx = useContext(MatchContext);\n  const route = useRouteNameRaw();\n  const getIndex = createMemo<undefined | [number, string]>(() => {\n    const here = route();\n    const children = props.children;\n    for (let i = 0; i < children.length; i ++) {\n      const [target, when] = doesMatch(ctx, here, children[i]);\n      if (when) return [i, target];\n    }\n    return undefined;\n  }, undefined, (a, b) => a === b || a !== undefined && b !== undefined && a[0] === b[0]);\n\n  return () => {\n    const ix = getIndex();\n    if (ix !== undefined) {\n      const [i, target] = ix;\n      return (\n        <MatchContext.Provider value={target}>\n          {props.children[i].children}\n        </MatchContext.Provider>);\n    }\n    return props.fallback;\n  };\n}\n\nexport type ShowRouteProps =\n  MatchRouteProps & { fallback?: JSX.Element };\n\nexport function ShowRoute(props: ShowRouteProps): JSX.Element {\n  const getMatch = createGetMatch(props);\n  return () => {\n    const [target, when] = getMatch();\n    return (\n      <Show when={when} fallback={props.fallback}>\n        <MatchContext.Provider value={target}>\n          {props.children}\n        </MatchContext.Provider>\n      </Show>);\n  };\n}\n","import { UnionToIntersection } from 'ts-essentials';\nimport { createState, createEffect, createMemo } from 'solid-js';\nimport { useRouteName } from '../context';\nimport { MatchRouteProps, SwitchRoutes } from './MatchRoute';\n\n/** A tree of route path segments */\nexport type RenderTreeOf<Tree> =\n  Owned<Tree> | RenderNode &\n  UnionToIntersection<\n    Tree extends readonly (infer Node)[]\n    ? Node extends { name: infer Name, children?: infer Children }\n      ? Name extends (string | number | symbol)\n        ? Children extends {}\n          ? { [K in Name]?: RenderTreeOf<Children> }\n          : { [K in Name]?: Owned<Children> | RenderNode }\n        : never\n      : never\n    : never\n  >;\n\nexport interface RenderNode {\n  render?(props: { children: JSX.Element }): JSX.Element,\n  fallback?(): JSX.Element,\n};\n\nexport type OwnedBy<Tree, Props> =\n  GetPropsWith<GetProps<Props>,\n    UnionToIntersection<\n      Tree extends readonly (infer Node)[]\n      ? Node extends { name: infer Name, children?: infer Children }\n        ? Name extends (string | number | symbol)\n          ? Children extends {}\n            ? { [K in Name]?: GetPropsWith<GetProps<Props>, OwnedBy<Children, Props>> }\n            : { [K in Name]?: GetProps<Props> }\n          : never\n        : never\n      : never\n    >\n  >;\n\n/**\n * Allows for conflicts between prop names and route names. At runtime what is a\n * prop or not is simply determined by whether it's a function or not.\n */\ntype GetPropsWith<Props, Tree>\n  = { [K in keyof Props & keyof Tree]: Tree[K] | Props[K] }\n  & Omit<{ [K in keyof Props]: Props[K] }, keyof Props>\n  & Omit<{ [K in keyof Tree]: Tree[K] }, keyof Tree>;\n\nexport interface OwnedOps<Tree, Props> {\n  render: (props: Props) => JSX.Element,\n\n  /**\n   * Default prop values for when no matches are found. Props that are optional\n   * should be typed as such within `Props` itself.\n   */\n  defaultProps?: Props,\n\n  /**\n   * Default prop values for when no matches are found. Props that are optional\n   * should be typed as such within `Props` itself.\n   */\n  defaultGetProps?: GetProps<Props>,\n\n  /**\n   * A tree of route paths and prop getters. A prop getter is a function of type\n   * `() => PropValue`. The key of the getter determines what prop it gets, and\n   * the type of that prop.\n   *\n   * The tree can go as deep as `Tree` will allow for, with each non-function\n   * key corresponding to a path segment in a route.\n   */\n  props: OwnedBy<Tree, Props>,\n}\n\n/** Existential wrapper around `OwnedOps` that hides the inner `Tree` and\n * `Props` types */\nexport type Owned<Tree> =\n  <R>(cont: <Props>(self: OwnedOps<Tree, Props>) => R) => R;\n\n/** Turn an object into the same object, but all its properties are optional and\n * made into functions returning their value */\nexport type GetProps<Props> =\n  { [K in keyof Props]?: () => Props[K] };\n\n/**\n * Helper function. Use this as a `render` function to just render the children\n * only.\n */\nexport function passthru<T>(props: { children: T }): T {\n  return props.children;\n}\n\nexport default function RouteStateMachine<R extends RenderTreeLike>(tree: R): JSX.Element {\n  const getRouteName = useRouteName();\n\n  function traverseHydrate<Props>(\n    path0: string[],\n    node0: GetPropsLike<Props>,\n    Render: (props: Props) => JSX.Element,\n    defaultGetProps: undefined | GetProps<Props>,\n    defaultProps: undefined | Props,\n  ): JSX.Element {\n    const [state, setState] = createState(defaultProps ?? {});\n\n    const numDefaultGetProps = Object.keys(defaultProps??{}).length;\n\n    const getPathSuffix = createMemo<[string, string[]]>(() => {\n      const p = getRouteName();\n      p.splice(0, path0.length);\n      return [name, p];\n    }, undefined, (a, b) => a && a[0] === b[0]);\n\n    function populate(\n      path: string[],\n      node: GetPropsLike<Props>,\n      next: Partial<Props>,\n      count: number,\n    ): number {\n      for (const key in node) {\n        const gp = (node as GetProps<Props>)[key as keyof Props];\n        if (typeof gp === 'function') {\n          const value = gp();\n          next[key as keyof Props] = value;\n          count ++;\n          continue;\n        }\n        if (gp !== undefined) {\n          if (path[0] === key) {\n            return populate(path.slice(1), gp as any, next, count);\n          }\n        }\n      }\n      return count;\n    }\n\n    function populateFromDefaultGetProps(next: Partial<Props>): number {\n      if (defaultGetProps === undefined) { return 0; }\n      let count = 0;\n      for (const k_ in defaultGetProps) {\n        const k: keyof Props = k_;\n        if (next[k] === undefined) {\n          const fn = defaultGetProps[k];\n          if (typeof fn === 'function') {\n            next[k as keyof Props] = fn();\n            count ++;\n          }\n        }\n      }\n      return count;\n    }\n\n    createEffect(() => {\n      const next: Partial<Props> = {};\n      let got = populate(getPathSuffix()[1], node0, next, 0);\n      if (got < numDefaultGetProps) { got += populateFromDefaultGetProps(next); }\n      if (got > 0) { setState(next); }\n    });\n\n    return <Render {...state as Props} />;\n  }\n\n  function traverse(\n    path: string[],\n    node: RenderTreeLike,\n  ): JSX.Element {\n    if (typeof node === 'function') {\n      return node(function <Props>(owned: OwnedOpsLike<Props>) {\n        const { props, render, defaultGetProps, defaultProps } = owned;\n        return traverseHydrate(path, props, render, defaultGetProps, defaultProps);\n      });\n    }\n\n    const children: MatchRouteProps[] = [];\n\n    const {\n      render: RenderHere = passthru,\n      fallback: Fallback = () => undefined,\n      ...routes\n    } = node;\n\n    for (const key in routes) {\n      const next = [...path, key];\n      const child = routes[key];\n      children.push({\n        prefix: key,\n        children: () => traverse(next, child),\n      });\n    }\n\n    return (\n      <RenderHere>\n        <SwitchRoutes fallback={Fallback} children={children} />\n      </RenderHere>);\n  }\n\n  return traverse([], tree);\n}\n\n/**\n * Monomorphic-ish version of 'GetProps'\n */\nexport type GetPropsLike<Props> =\n  { [k: string]: GetPropsLike<Props> } & GetProps<Props>;\n\n/**\n * Monomorphic-ish version of 'OwnedOps'\n */\nexport interface OwnedOpsLike<Props> {\n  render: (props: Props) => JSX.Element,\n  defaultProps?: Props,\n  defaultGetProps?: GetProps<Props>,\n  props: GetPropsLike<Props>\n}\n\n/**\n * Monomorphic-ish version of 'Owned'\n */\nexport type OwnedLike =\n  (cont: <Props>(self: OwnedOpsLike<Props>) => any) => any;\n\n/**\n * Monomorphic-ish version of 'RenderTreeOf'\n */\nexport type RenderTreeLike\n  = OwnedLike\n  | (RenderNode & { [k: string]: RenderTreeLike });\n","import { State as RouteState, Router as Router5, Route } from 'router5';\nimport { createSignal, createEffect, createMemo } from 'solid-js';\n\nimport { SharedRouterValue, RoutesLike } from './types';\nimport Context from './context';\nimport createLink, { LinkProps, RouteNameOf } from './components/Link';\nimport RouteStateMachine, { RenderTreeOf, RenderTreeLike } from './components/RouteTree';\nimport { DefaultDependencies } from 'router5/dist/types/router';\n\nexport { LinkNav } from './components/Link';\nexport { MatchRoute, ShowRoute } from './components/MatchRoute';\nexport { passthru } from './components/RouteTree';\nexport { useRoute, useRouteName, useActive, isActive } from './context';\n\nexport type { MatchRouteProps, ShowRouteProps } from './components/MatchRoute';\nexport type { LinkProps, RouteNameOf } from './components/Link';\nexport type { RenderTreeOf } from './components/RouteTree';\nexport type { RoutesLike, SharedRouterValue, RouterContextValue } from './types';\n\n/**\n * Create a router for use in solid-js.\n *\n * I'd recommend putting your router in its own file like './router.ts', then\n * exporting the results of this function, like\n *\n * ```ts\n * import { createRouter, Router as Router5 } from 'router5';\n * import { createSolidRouter } from 'solid-ts-router';\n *\n * const routes = [\n *   ...\n * ] as const;\n *\n * // note the \"as const\" is very important! this causes TypeScript to infer\n * // `routes` as the narrowest possible type.\n *\n * function performInitialRedirect(router: Router5) {\n *   ...\n * }\n *\n * export const { Provider, Link, Router } = createSolidRouter(routes, routes => {\n *   return createRouter(routes, {...router5OptionsHere});\n * }, performInitialRedirect);\n * ```\n */\nexport default function createSolidRouter<Routes extends RoutesLike<Deps>, Deps = DefaultDependencies>(\n  routes: Routes,\n  createRouter5: (routes: Route<Deps>[]) => Router5<Deps>,\n  onStart?: (router: Router5<Deps>) => void,\n): {\n  Provider(props: { children: JSX.Element }): JSX.Element,\n  Link(props: LinkProps<RouteNameOf<Routes>>): JSX.Element,\n  Router(props: { children: RenderTreeOf<Routes> }): JSX.Element,\n  router: SharedRouterValue<Deps, Routes>,\n  hints: Phantom<{\n    routes: Routes,\n    name: RouteNameOf<Routes>,\n    tree: RenderTreeOf<Routes>\n  }>,\n} {\n  const router5: Router5<Deps> = createRouter5(routes as any as Route<Deps>[]);\n  // yolo, hopefully router5 doesn't actually mutate routes =)\n\n  const self: SharedRouterValue<Deps, Routes> = { routes, router5 };\n  Object.freeze(self);\n\n  return {\n    Link: createLink(self),\n\n    Router(props: { children: RenderTreeOf<Routes> }): JSX.Element {\n      return RouteStateMachine(props.children as RenderTreeLike);\n    },\n\n    Provider(props: { children: JSX.Element }): JSX.Element {\n      const initialState = router5.getState() ?? { name: '' };\n      const [getRoute, setRoute] = createSignal<RouteState>(initialState);\n\n      const getRouteName = createMemo(() => getRoute().name, initialState.name, (a, b) => a === b);\n      const getSplitRouteName = createMemo(() => getRouteName().split('.'), initialState.name.split('.'));\n\n      const value = {\n        getRoute,\n        getRouteName: getSplitRouteName,\n        getRouteNameRaw: getRouteName,\n        router: self as SharedRouterValue<unknown, unknown>,\n      };\n\n      createEffect(() => {\n        router5.subscribe((state) => setRoute(state.route));\n        router5.start();\n        if (typeof onStart === 'function') onStart(router5);\n      });\n\n      return (\n        <Context.Provider value={value}>\n          {props.children}\n        </Context.Provider>);\n    },\n    router: self,\n    hints: {} as any,\n  };\n}\n\nexport type Phantom<T> = { __phantom__: never } & T;\n"],"names":["Context","createContext","useRoute","useContext","getRoute","useRouteName","getRouteName","useRouteNameRaw","getRouteNameRaw","useActive","link","createMemo","isActive","here","length","i","LinkNav","renderRouteLike","route","join","defaultLinkConfig","navActiveClassName","createLink","self","config","router5","props","getClassList","classList","type","undefined","nav","to","getInnerProps","_cl","onClick","_oc","innerProps","getHref","buildPath","params","err","console","warn","disabled","ev","preventDefault","navigate","Back","window","history","back","target","blur","MatchContext","doesMatch","ctx","suffix","path","prefix","exact","startsWith","createGetMatch","a","b","MatchRoute","getMatch","children","SwitchRoutes","getIndex","when","ix","fallback","ShowRoute","passthru","RouteStateMachine","tree","traverseHydrate","path0","node0","Render","defaultGetProps","defaultProps","state","setState","createState","numDefaultGetProps","Object","keys","getPathSuffix","p","splice","name","populate","node","next","count","key","gp","value","slice","populateFromDefaultGetProps","k_","k","fn","createEffect","got","traverse","owned","render","RenderHere","Fallback","routes","child","push","createSolidRouter","createRouter5","onStart","freeze","Link","Router","Provider","initialState","getState","setRoute","createSignal","getSplitRouteName","split","router","subscribe","start","hints"],"mappings":"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"}