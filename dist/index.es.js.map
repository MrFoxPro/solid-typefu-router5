{"version":3,"file":"index.es.js","sources":["../src/context.ts","../src/components/Link.tsx","../src/components/MatchRoute.tsx","../src/components/RouteTree.tsx","../src/index.tsx"],"sourcesContent":["import { createContext, useContext, createMemo } from 'solid-js';\nimport { RouterContextValue } from './types';\nimport { State as RouteState } from 'router5';\nimport { RouteLike } from 'components/Link';\n\nconst Context = createContext<RouterContextValue>();\n\nexport default Context;\n\nexport function useRoute(): () => RouteState {\n  return useContext(Context).getRoute;\n}\n\nexport function useRouteName(): () => readonly string[] {\n  return useContext(Context).getRouteName;\n}\n\nexport function useRouteNameRaw(): () => string {\n  return useContext(Context).getRouteNameRaw;\n}\n\nfunction shallowStringyEq<\n  A extends Record<string, any>,\n  B extends Record<string, any>\n>(a: A, b: B): boolean {\n  if (a === b) return true;\n  const keys = Object.keys(a);\n  for (const key of keys) if (!(key in b)) return false;\n  for (const key of keys) if (String(a[key]) !== String(b[key])) return false;\n  return keys.length === Object.keys(b).length;\n}\n\nexport function useIsActive<Link extends RouteLike>(\n  link: Link,\n  params?: Record<string, any>,\n  isEqual: <A extends Record<string, any>, B extends Record<string, any>>(a: A, b: B) => boolean = shallowStringyEq,\n): () => boolean {\n  const getRouteName = useRouteName();\n  const getIsActiveByName = createMemo(() => isActive(getRouteName(), link));\n  if (params === undefined) return getIsActiveByName;\n  const getRoute = useRoute();\n  const getRouteParams = createMemo(() => getRoute().params);\n  return createMemo(() => {\n    const routeParams = getRouteParams();\n    return getIsActiveByName() && isEqual(routeParams, params);\n  });\n}\n\n/**\n * Find whether 'link' is an ancestor of, or equal to, 'here'\n *\n * Maybe useful for creating your own `Link` component.\n */\nexport function isActive<Link extends RouteLike>(here: readonly string[], link: Link) {\n  if (here.length === 0) { return false; }\n  if (typeof link === 'string') { return here[0] === link; }\n  // if link has more segments than here then it definitely cannot be an\n  // ancestor of here\n  if (link.length > here.length) return false;\n  for (let i = 0; i < link.length; i ++) {\n    if (link[i] !== here[i]) return false;\n  }\n  return true;\n}\n","import { SharedRouterValue, RoutesLike } from \"../types\";\nimport { useIsActive } from \"../context\";\nimport { createMemo, splitProps } from \"solid-js\";\n\nexport enum LinkNav {\n  Back = \"back\",\n  Forward = \"forward\",\n}\n\n/** Props for making a `Link` component.\n *\n * @remarks\n *\n * Only some of the props are reactive; the rest are static at the time of\n * creating the link. The reactive props available are:\n *\n * - `to`\n * - `params`\n * - `disabled`\n * - `onClick`\n * - `innerProps`\n * - `disabledProps`\n */\nexport type LinkProps<Route> = {\n  disabled?: boolean;\n  nav?: boolean;\n  navIgnoreParams?: boolean;\n  onClick?: (\n    ev: MouseEvent & {\n      target: HTMLAnchorElement;\n      currentTarget: HTMLAnchorElement;\n    }\n  ) => void;\n} & (\n  | {\n      type: LinkNav.Back | LinkNav.Forward;\n      to?: undefined;\n      params?: undefined;\n    }\n  | {\n      type?: undefined;\n      to: Route;\n      params?: Record<string, any>;\n    }\n) &\n  Omit<JSX.IntrinsicElements[\"a\" | \"button\"], \"onClick\" | \"href\" | \"type\">;\n\nexport interface LinkConfig {\n  navActiveClassName: string;\n}\n\nexport type RouteLike = string | string[];\n\nexport function renderRouteLike(route: RouteLike) {\n  if (typeof route === \"string\") return route;\n  return route.join(\".\");\n}\n\nexport const defaultLinkConfig: LinkConfig = {\n  navActiveClassName: \"is-active\",\n};\n\nexport default function createLink<\n  Deps,\n  Routes extends RoutesLike<Deps>,\n  RouteName extends RouteNameOf<Routes> & RouteLike\n>(\n  self: SharedRouterValue<Deps, Routes>,\n  config: Partial<LinkConfig> = defaultLinkConfig\n): (props: LinkProps<RouteName>) => JSX.Element {\n  const { router5 } = self;\n\n  const { navActiveClassName = defaultLinkConfig.navActiveClassName } = config;\n\n  return (props: LinkProps<RouteName>): JSX.Element => {\n    const [linkProps, innerProps] = splitProps(props, [\n      \"type\",\n      \"onClick\",\n      \"classList\",\n      \"to\",\n      \"params\",\n      \"nav\",\n      \"navIgnoreParams\",\n      \"disabled\",\n    ]);\n\n    const isActive =\n      linkProps.to !== undefined\n        ? useIsActive(\n            linkProps.to,\n            linkProps.navIgnoreParams ? undefined : linkProps.params\n          )\n        : alwaysInactive;\n\n    const getClassList = createMemo(() => {\n      const classList = linkProps.classList ?? {};\n      if (linkProps.type === undefined && linkProps.nav) {\n        classList[navActiveClassName] = isActive();\n        return classList;\n      }\n      return classList;\n    });\n\n    const getHref: () => string | undefined = createMemo(() => {\n      if (linkProps.type === undefined) {\n        try {\n          return router5.buildPath(\n            renderRouteLike(linkProps.to as RouteName),\n            linkProps.params\n          );\n        } catch (err) {\n          console.warn(\"<Link> buildPath failed:\", err);\n        }\n      }\n      return undefined;\n    });\n\n    return () =>\n      linkProps.disabled ? (\n        <button\n          {...(innerProps as JSX.IntrinsicElements[\"button\"])}\n          disabled\n          classList={getClassList()}\n        />\n      ) : (\n        <a\n          {...(innerProps as JSX.IntrinsicElements[\"a\"])}\n          classList={getClassList()}\n          href={getHref()}\n          onClick={(ev) => {\n            ev.preventDefault();\n            switch (props.type) {\n              case undefined:\n                router5.navigate(\n                  renderRouteLike(linkProps.to as RouteLike),\n                  linkProps.params ?? {}\n                );\n                if (typeof linkProps.onClick === \"function\")\n                  linkProps.onClick(ev);\n                break;\n              case LinkNav.Back:\n                window.history.back();\n                break;\n              case LinkNav.Back:\n                window.history.back();\n                break;\n            }\n            ev.target.blur();\n          }}\n        />\n      );\n  };\n}\n\nconst alwaysInactive = () => false;\n\nexport type FlattenRouteName<A> = A extends [infer X]\n  ? X\n  : A extends [infer X, ...infer XS]\n  ? X extends string\n    ? XS extends string[]\n      ? `${X}.${FlattenRouteName<XS>}`\n      : never\n    : never\n  : A extends string\n  ? A\n  : \"\";\n\nexport type RouteNameOf<A> = FlattenRouteName<RouteArrayOf<A>>;\n\nexport type ToRouteArray<A> = A extends string\n  ? A extends `${infer X}.${infer XS}`\n    ? [X, ...ToRouteArray<XS>]\n    : [A]\n  : [];\n\nexport type RouteArrayOf<A> = A extends readonly (infer U)[]\n  ? U extends { name: infer Name; children: infer Children }\n    ? Children extends {}\n      ? ToRouteArray<Name> | [...ToRouteArray<Name>, ...RouteArrayOf<Children>]\n      : ToRouteArray<Name>\n    : U extends { name: infer Name }\n    ? ToRouteArray<Name>\n    : []\n  : [];\n\nexport type UnOne<A> = A extends [infer U] ? U : A;\n","import { createContext, useContext, Match, Show, createMemo } from \"solid-js\";\nimport { useRouteNameRaw } from \"../context\";\n\nconst MatchContext = createContext<string>(\"\");\n\nexport type MatchRouteProps = PathProps & { children: JSX.Element };\n\nexport interface ExactPathProps {\n  path: string;\n  prefix?: undefined;\n}\n\nexport interface PrefixPathProps {\n  prefix: string;\n  path?: undefined;\n}\n\n/**\n * ```ts\n * type PathProps = { path: string } | { prefix: string };\n * ```\n *\n * If [[ExactPathProps.path]] is given, then the match is exact, which means\n * that the current route name must be equal to `context.path + path` where\n * `context.path` means the current path created by other match components above\n * this one.\n *\n * If [[PrefixPathProps.prefix]] is given, then the match only requires that the\n * current route start with `context.path + prefix`.\n *\n */\nexport type PathProps = ExactPathProps | PrefixPathProps;\n\nfunction doesMatch(\n  ctx: string,\n  here: string,\n  props: PathProps\n): [string, boolean] {\n  const suffix = props.path !== undefined ? props.path : props.prefix;\n  const exact = props.path !== undefined;\n  const target = ctx !== \"\" ? `${ctx}.${suffix}` : suffix;\n  return [target, exact ? here === target : here.startsWith(target)];\n}\n\n/**\n * Not reactive on the routes being used\n *\n * Prefer this over [[Switch]] + [[MatchRoute]]\n */\nexport function SwitchRoutes(props: {\n  children: MatchRouteProps[];\n  fallback?: JSX.Element;\n}): JSX.Element {\n  const ctx = useContext(MatchContext);\n  const route = useRouteNameRaw();\n  const getIndex = createMemo<undefined | [number, string]>(\n    () => {\n      const here = route();\n      const children = props.children;\n      for (let i = 0; i < children.length; i++) {\n        const [target, when] = doesMatch(ctx, here, children[i]);\n        if (when) return [i, target];\n      }\n      return undefined;\n    },\n    undefined,\n    (a, b) => {\n      const same =\n        a === b || (a !== undefined && b !== undefined && a[0] === b[0]);\n      return same;\n    }\n  );\n  return createMemo(() => {\n    const ix = getIndex();\n    if (ix !== undefined) {\n      const [i, target] = ix;\n      return (\n        <MatchContext.Provider value={target}>\n          {props.children[i].children}\n        </MatchContext.Provider>\n      );\n    }\n    return props.fallback;\n  });\n}\n\nexport type ShowRouteProps = MatchRouteProps & { fallback?: JSX.Element };\n\n/**\n * Create a [[Show]] node against a given route.\n */\nexport function ShowRoute(props: ShowRouteProps): JSX.Element {\n  const getMatch = createGetMatch(props);\n  return () => {\n    const [target, when] = getMatch();\n    return (\n      <Show when={when} fallback={props.fallback}>\n        <MatchContext.Provider value={target}>\n          {props.children}\n        </MatchContext.Provider>\n      </Show>\n    );\n  };\n}\n\n/**\n * Create a [[Match]] node against a given route.\n */\nexport function MatchRoute(props: MatchRouteProps): JSX.Element {\n  const getMatch = createGetMatch(props);\n  return (\n    <Match when={getMatch()[1]}>\n      <MatchContext.Provider value={getMatch()[0]}>\n        {props.children}\n      </MatchContext.Provider>\n    </Match>\n  );\n}\n\nfunction createGetMatch(props: PathProps): () => [string, boolean] {\n  const route = useRouteNameRaw();\n  const ctx = useContext(MatchContext);\n  return createMemo<[string, boolean]>(\n    () => doesMatch(ctx, route(), props),\n    undefined,\n    (a, b) => a && a[1] === b[1]\n  );\n}\n","import { UnionToIntersection } from \"ts-essentials\";\nimport {\n  createComponent,\n  createComputed,\n  createMemo,\n  createState,\n  untrack,\n} from \"solid-js\";\nimport { useRouteName } from \"../context\";\nimport { MatchRouteProps, SwitchRoutes } from \"./MatchRoute\";\nimport { RouteLike, ToRouteArray } from \"./Link\";\n\n/**\n * Given a tree of routes and render instructions for each route, return an\n * element that selects the correct renderer for the current route.\n *\n * Also supports using routes to choose how to provide props to a single\n * renderer.\n */\nexport default function RouteStateMachine<\n  T extends RenderTreeLike,\n  A extends RouteLike\n>(tree: T, _assumed?: A): JSX.Element {\n  const getRouteName = useRouteName();\n\n  function traverseHydrate<Props>(\n    path0: string[],\n    node0: GetPropsLike<Props>,\n    Render: (props: Props) => JSX.Element,\n    defaultProps: undefined | Props\n  ): JSX.Element {\n    const noProps = defaultProps ?? ({} as Props);\n    const [state, setState] = createState(noProps);\n\n    const getPathSuffix = createMemo<string[]>(\n      () => getRouteName().slice(path0.length),\n      [],\n      (a, b) => {\n        if (a === b) return true;\n        if (a.length !== b.length) return false;\n        for (let i = 0; i < a.length; i++) {\n          const x = a[i];\n          const y = b[i];\n          if (x !== y) return false;\n        }\n        return true;\n      }\n    );\n\n    function populate(\n      path: string[],\n      node: GetPropsLike<Props>,\n      next: Partial<Props>,\n      counter: { updated: number }\n    ) {\n      for (const key in node) {\n        const gp = (node as GetProps<Props>)[key as keyof Props];\n        if (typeof gp === \"function\") {\n          const value = gp();\n          if (value === (state as Props)[key as keyof Props]) continue;\n          next[key as keyof Props] = value;\n          counter.updated++;\n          continue;\n        }\n        if (gp !== undefined) {\n          if (path[0] === key) {\n            populate(path.slice(1), gp as any, next, counter);\n          }\n        }\n      }\n    }\n\n    createComputed(() => {\n      const suffix = getPathSuffix();\n      untrack(() => {\n        const next: Partial<Props> = { ...(state as Props) };\n        const counter = { updated: 0 };\n        populate(suffix, node0, next, counter);\n        if (counter.updated > 0) {\n          setState(next);\n        }\n      });\n    });\n\n    return createComponent(Render, state as Props);\n  }\n\n  function traverse(\n    path: string[],\n    node: RenderTreeOf<RouteTreeLike>\n  ): JSX.Element {\n    if (typeof node === \"function\") {\n      return node(function <Props>(owned: OwnedOps<RouteTreeLike, Props>) {\n        const { props, render, defaultProps } = owned;\n        return () => traverseHydrate(path, props, render, defaultProps);\n      });\n    }\n\n    const children: MatchRouteProps[] = [];\n    const { render: RenderHere = passthru, fallback, ...routes } = node;\n    for (const key in routes) {\n      const next = [...path, key];\n      const child = routes[key]!;\n      children.push({\n        prefix: key,\n        children: traverse(next, child),\n      });\n    }\n\n    return () => (\n      <RenderHere>\n        <SwitchRoutes fallback={fallback} children={children} />\n      </RenderHere>\n    );\n  }\n\n  return untrack(() => traverse([], tree as RenderTreeOf<RouteTreeLike>));\n}\n\n/**\n * Tells `solid-typefu-router5` how to render a node if the path leading to\n * it matches the current route name.\n */\nexport interface RenderNode {\n  /** Default: [[passthru]] */\n  render?: (props: { children?: JSX.Element }) => JSX.Element;\n  /** Fallback children to use if none are available to give to [[render]]. Default: nothing */\n  fallback?: JSX.Element;\n}\n\nexport interface OwnedOps<Tree, Props> {\n  /**\n   * @remarks If this has a concrete type for its props then TypeScript will be\n   * able to infer the structure of [[props]].\n   */\n  render: (props: Props) => JSX.Element;\n\n  /**\n   * Default prop values for when no matches are found. Props that are optional\n   * should be typed as such within [[Props]] itself.\n   */\n  defaultProps?: Props;\n\n  /**\n   * A tree of route paths and prop getters. A prop getter is a function of type\n   * `() => PropValue`. The key of the getter determines what prop it gets, and\n   * the type of that prop.\n   *\n   * The tree can go as deep as [[Tree]] will allow for, with each non-function\n   * key corresponding to a path segment in a route.\n   */\n  props: OwnedBy<Tree, Props>;\n}\n\n/** Turn an object into the same object, but all its properties are optional and\n * made into functions returning their value */\nexport type GetProps<Props> = { [K in keyof Props]?: () => Props[K] };\n\n/** Existential wrapper around [[OwnedOps]] that hides the inner [[Tree]] and\n * [[Props]] types */\nexport type Owned<Tree> = <R>(\n  cont: <Props>(self: OwnedOps<Tree, Props>) => R\n) => R;\n\n/**\n * Helper function. Use this as a [[render]] function to just render the\n * children only.\n */\nexport function passthru<T>(props: { children: T }): T {\n  return props.children;\n}\n\n/** A tree of route path segments. Has the same structure as a\n * [[RenderTreeLike]], but the spine of the tree is fixed to use the given\n * [[Tree]] */\nexport type RenderTreeOf<Tree> =\n  | Owned<Tree>\n  | (RenderNode &\n      UnionToIntersection<\n        Tree extends readonly (infer Node)[]\n          ? Node extends { name: infer Name; children?: infer Children }\n            ? Name extends string | number | symbol\n              ? Children extends {}\n                ? { [K in Name]?: RenderTreeOf<Children> }\n                : { [K in Name]?: Owned<Children> | RenderNode }\n              : never\n            : never\n          : never\n      >);\n\nexport type OwnedBy<Tree, Props> = GetPropsWith<\n  GetProps<Props>,\n  UnionToIntersection<\n    Tree extends readonly (infer Node)[]\n      ? Node extends { name: infer Name; children?: infer Children }\n        ? Name extends string | number | symbol\n          ? Children extends {}\n            ? {\n                [K in Name]?: GetPropsWith<\n                  GetProps<Props>,\n                  OwnedBy<Children, Props>\n                >;\n              }\n            : { [K in Name]?: GetProps<Props> }\n          : never\n        : never\n      : never\n  >\n>;\n\n/**\n * Allows for conflicts between prop names and route names. At runtime what is a\n * prop or not is simply determined by whether it's a function or not.\n */\nexport type GetPropsWith<Props, Tree> = {\n  [K in keyof Props & keyof Tree]: Tree[K] | Props[K];\n} &\n  Omit<{ [K in keyof Props]: Props[K] }, keyof Tree> &\n  Omit<{ [K in keyof Tree]: Tree[K] }, keyof Props>;\n\n// monomorphic (in tree spine) helper types\n\nexport type GetPropsLike<Props> = {\n  [k: string]: GetPropsLike<Props>;\n} & GetProps<Props>;\nexport type RouteNodeLike = { name: string; children?: RouteTreeLike };\nexport type RouteTreeLike = RouteNodeLike[];\nexport type RenderTreeLike =\n  | OwnedLike\n  | (RenderNode & { [k: string]: RenderTreeLike });\nexport type OwnedLike = <R>(cont: <Props>(self: OwnedOpsLike<Props>) => R) => R;\nexport interface OwnedOpsLike<Props> {\n  render: (props: Props) => JSX.Element;\n  defaultProps?: Props;\n  props: GetPropsLike<Props>;\n}\n\nexport type DescendDef<Path, Tree> = Path extends [infer P1, ...infer PS]\n  ? Tree extends readonly (infer Node)[]\n    ? Node extends { name: infer Name; children?: infer Children }\n      ? Name extends P1\n        ? Defer<DescendDef<PS, Children>>\n        : never\n      : never\n    : never\n  : Tree;\n\ntype One<T> = T extends any[] ? T : [T];\nexport type Descend<P, T> = Undefer<DescendDef<One<ToRouteArray<P>>, T>>;\n\n// Same trick as in https://github.com/microsoft/TypeScript/pull/21613\ninterface Defer<X> {\n  ____defer: Undefer<X>;\n}\ntype Undefer<X> = X extends { ____defer: infer U } ? U : X;\n","import { State as RouteState, Router as Router5, Route } from \"router5\";\nimport { DefaultDependencies } from \"router5/dist/types/router\";\nimport { Unsubscribe } from \"router5/dist/types/base\";\nimport { createSignal, createEffect, createMemo, onCleanup } from \"solid-js\";\nimport { SharedRouterValue, RoutesLike } from \"./types\";\nimport Context from \"./context\";\nimport createLink, {\n  LinkConfig,\n  LinkProps,\n  RouteLike,\n  RouteNameOf,\n} from \"./components/Link\";\nimport RouteStateMachine, {\n  RenderTreeOf,\n  RenderTreeLike,\n  Descend,\n} from \"./components/RouteTree\";\n\nexport { LinkNav } from \"./components/Link\";\nexport { MatchRoute, ShowRoute, SwitchRoutes } from \"./components/MatchRoute\";\nexport { passthru } from \"./components/RouteTree\";\nexport {\n  default as Context,\n  useRoute,\n  useRouteName,\n  useIsActive,\n  isActive,\n} from \"./context\";\n\nexport type { MatchRouteProps, ShowRouteProps } from \"./components/MatchRoute\";\nexport type {\n  LinkConfig,\n  LinkProps,\n  RouteArrayOf,\n  RouteNameOf,\n} from \"./components/Link\";\nexport type { RenderTreeOf } from \"./components/RouteTree\";\nexport type {\n  RoutesLike,\n  SharedRouterValue,\n  RouterContextValue,\n} from \"./types\";\n\nexport interface Config<Deps> {\n  createRouter5: (\n    routes: Route<Deps>[]\n  ) => Router5<Deps> | [Router5<Deps>, ...Unsubscribe[]];\n  onStart?: (router: Router5<Deps>) => void;\n  link?: LinkConfig;\n}\n\n/**\n * Create a router for use in solid-js.\n *\n * I'd recommend putting your router in its own file like './router.ts', then\n * exporting the results of this function, like\n *\n * ```ts\n * import { createRouter, Router as Router5 } from 'router5';\n * import { createSolidRouter } from 'solid-ts-router';\n *\n * const routes = [\n *   ...\n * ] as const;\n *\n * // note the \"as const\" is very important! this causes TypeScript to infer\n * // `routes` as the narrowest possible type.\n *\n * function createRouter5(routes: Route<Deps>[]): Router5 {\n *   return createRouter(...)\n * }\n *\n * function onStart(router: Router5): void {\n *   // initial redirect here\n *   ...\n * }\n *\n * export const { Provider, Link, Router } = createSolidRouter(routes, { createRouter5, onStart });\n * ```\n */\nexport default function createSolidRouter<\n  Routes extends RoutesLike<Deps>,\n  Deps = DefaultDependencies\n>(\n  routes: Routes,\n  { createRouter5, onStart, link: linkConfig }: Config<Deps>\n): {\n  Provider(props: { children: JSX.Element }): JSX.Element;\n\n  /** See [[createLink]] */\n  Link(props: LinkProps<RouteNameOf<Routes>>): JSX.Element;\n\n  /** See [[RouteStateMachine]] */\n  Router<AssumePath extends RouteNameOf<Routes> | undefined>(props: {\n    children: AssumePath extends string\n      ? RenderTreeOf<Descend<AssumePath, Routes>>\n      : RenderTreeOf<Routes>;\n    assume?: AssumePath;\n  }): JSX.Element;\n\n  /** Probably don't use this. */\n  router: SharedRouterValue<Deps, Routes>;\n\n  /**\n   * Type hints you can use to give type names to aspects of your router like\n   *\n   * ```typescript\n   * type Hints = typeof hints;\n   * export type RouteName = Hints['name'];\n   * ```\n   */\n  hints: Phantom<{\n    routes: Routes;\n    name: RouteNameOf<Routes>;\n    tree: RenderTreeOf<Routes>;\n  }>;\n} {\n  const [router5, unsubs] = (() => {\n    let router5: Router5<Deps>;\n    let unsubs: Unsubscribe[];\n    const r = createRouter5((routes as any) as Route<Deps>[]);\n    if (Array.isArray(r)) {\n      [router5, ...unsubs] = r;\n    } else {\n      router5 = r;\n      unsubs = [];\n    }\n    return [router5, unsubs] as const;\n  })();\n\n  // yolo, hopefully router5 doesn't actually mutate routes =)\n  const self: SharedRouterValue<Deps, Routes> = { routes, router5 };\n  Object.freeze(self);\n\n  return {\n    Link: createLink(self, linkConfig),\n\n    Router(props) {\n      return RouteStateMachine(\n        props.children as RenderTreeLike,\n        props.assume as RouteLike\n      );\n    },\n\n    Provider(props: { children: JSX.Element }): JSX.Element {\n      const initialState = router5.getState() ?? { name: \"\" };\n      const [getRoute, setRoute] = createSignal<RouteState>(initialState);\n\n      const getRouteName = createMemo(\n        () => getRoute().name,\n        initialState.name,\n        (a, b) => a === b\n      );\n\n      const getSplitRouteName = createMemo(\n        () => Object.freeze(getRouteName().split(\".\")),\n        initialState.name.split(\".\")\n      );\n\n      const value = {\n        getRoute,\n        getRouteName: getSplitRouteName,\n        getRouteNameRaw: getRouteName,\n        router: self as SharedRouterValue<unknown, unknown>,\n      };\n\n      createEffect(() => {\n        router5.subscribe((state) => setRoute(Object.freeze(state.route)));\n        router5.start();\n        if (typeof onStart === \"function\") onStart(router5);\n      });\n\n      onCleanup(() => {\n        for (const unsub of unsubs) {\n          unsub();\n        }\n        router5.stop();\n      });\n\n      return (\n        <Context.Provider value={value}>{props.children}</Context.Provider>\n      );\n    },\n    router: self,\n    hints: {} as any,\n  };\n}\n\nexport type Phantom<T> = { __phantom__: never } & T;\n"],"names":["Context","createContext","useRoute","useContext","getRoute","useRouteName","getRouteName","useRouteNameRaw","getRouteNameRaw","shallowStringyEq","a","b","keys","Object","key","String","length","useIsActive","link","params","isEqual","getIsActiveByName","createMemo","isActive","undefined","getRouteParams","routeParams","here","i","LinkNav","renderRouteLike","route","join","defaultLinkConfig","navActiveClassName","createLink","self","config","router5","props","linkProps","innerProps","splitProps","to","navIgnoreParams","alwaysInactive","getClassList","classList","type","nav","getHref","buildPath","err","console","warn","disabled","ev","preventDefault","navigate","onClick","Back","window","history","back","target","blur","MatchContext","doesMatch","ctx","suffix","path","prefix","exact","startsWith","SwitchRoutes","getIndex","children","when","same","ix","fallback","ShowRoute","getMatch","createGetMatch","MatchRoute","RouteStateMachine","tree","_assumed","traverseHydrate","path0","node0","Render","defaultProps","noProps","state","setState","createState","getPathSuffix","slice","x","y","populate","node","next","counter","gp","value","updated","createComputed","untrack","createComponent","traverse","owned","render","RenderHere","passthru","routes","child","push","createSolidRouter","createRouter5","onStart","linkConfig","unsubs","r","Array","isArray","freeze","Link","Router","assume","Provider","initialState","getState","name","setRoute","createSignal","getSplitRouteName","split","router","createEffect","subscribe","start","onCleanup","unsub","stop","hints"],"mappings":";;;MAKMA,OAAO,GAAGC,aAAa;SAIbC;AACd,SAAOC,UAAU,CAACH,OAAD,CAAV,CAAoBI,QAA3B;AACD;SAEeC;AACd,SAAOF,UAAU,CAACH,OAAD,CAAV,CAAoBM,YAA3B;AACD;SAEeC;AACd,SAAOJ,UAAU,CAACH,OAAD,CAAV,CAAoBQ,eAA3B;AACD;;AAED,SAASC,gBAAT,CAGEC,CAHF,EAGQC,CAHR;AAIE,MAAID,CAAC,KAAKC,CAAV,EAAa,OAAO,IAAP;AACb,QAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,CAAZ,CAAb;;AACA,OAAK,MAAMI,GAAX,IAAkBF,IAAlB,EAAwB,IAAI,EAAEE,GAAG,IAAIH,CAAT,CAAJ,EAAiB,OAAO,KAAP;;AACzC,OAAK,MAAMG,GAAX,IAAkBF,IAAlB,EAAwB,IAAIG,MAAM,CAACL,CAAC,CAACI,GAAD,CAAF,CAAN,KAAmBC,MAAM,CAACJ,CAAC,CAACG,GAAD,CAAF,CAA7B,EAAuC,OAAO,KAAP;;AAC/D,SAAOF,IAAI,CAACI,MAAL,KAAgBH,MAAM,CAACD,IAAP,CAAYD,CAAZ,EAAeK,MAAtC;AACD;;SAEeC,YACdC,MACAC,QACAC,UAAiGX;AAEjG,QAAMH,YAAY,GAAGD,YAAY,EAAjC;AACA,QAAMgB,iBAAiB,GAAGC,UAAU,CAAC,MAAMC,QAAQ,CAACjB,YAAY,EAAb,EAAiBY,IAAjB,CAAf,CAApC;AACA,MAAIC,MAAM,KAAKK,SAAf,EAA0B,OAAOH,iBAAP;AAC1B,QAAMjB,QAAQ,GAAGF,QAAQ,EAAzB;AACA,QAAMuB,cAAc,GAAGH,UAAU,CAAC,MAAMlB,QAAQ,GAAGe,MAAlB,CAAjC;AACA,SAAOG,UAAU,CAAC;AAChB,UAAMI,WAAW,GAAGD,cAAc,EAAlC;AACA,WAAOJ,iBAAiB,MAAMD,OAAO,CAACM,WAAD,EAAcP,MAAd,CAArC;AACD,GAHgB,CAAjB;AAID;AAED;;;;;;SAKgBI,SAAiCI,MAAyBT;AACxE,MAAIS,IAAI,CAACX,MAAL,KAAgB,CAApB,EAAuB;AAAE,WAAO,KAAP;AAAe;;AACxC,MAAI,OAAOE,IAAP,KAAgB,QAApB,EAA8B;AAAE,WAAOS,IAAI,CAAC,CAAD,CAAJ,KAAYT,IAAnB;AAA0B;AAE1D;;;AACA,MAAIA,IAAI,CAACF,MAAL,GAAcW,IAAI,CAACX,MAAvB,EAA+B,OAAO,KAAP;;AAC/B,OAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,IAAI,CAACF,MAAzB,EAAiCY,CAAC,EAAlC,EAAuC;AACrC,QAAIV,IAAI,CAACU,CAAD,CAAJ,KAAYD,IAAI,CAACC,CAAD,CAApB,EAAyB,OAAO,KAAP;AAC1B;;AACD,SAAO,IAAP;AACD;;;;IC3DWC;;AAAZ,WAAYA;AACVA,EAAAA,eAAA,SAAA;AACAA,EAAAA,kBAAA,YAAA;AACD,CAHD,EAAYA,OAAO,KAAPA,OAAO,KAAA,CAAnB;;SAiDgBC,gBAAgBC;AAC9B,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B,OAAOA,KAAP;AAC/B,SAAOA,KAAK,CAACC,IAAN,CAAW,GAAX,CAAP;AACD;AAEM,MAAMC,iBAAiB,GAAe;AAC3CC,EAAAA,kBAAkB,EAAE;AADuB,CAAtC;SAIiBC,WAKtBC,MACAC,SAA8BJ;AAE9B,QAAM;AAAEK,IAAAA;AAAF,MAAcF,IAApB;AAEA,QAAM;AAAEF,IAAAA,kBAAkB,GAAGD,iBAAiB,CAACC;AAAzC,MAAgEG,MAAtE;AAEA,SAAQE,KAAD;AACL,UAAM,CAACC,SAAD,EAAYC,UAAZ,IAA0BC,UAAU,CAACH,KAAD,EAAQ,CAChD,MADgD,EAEhD,SAFgD,EAGhD,WAHgD,EAIhD,IAJgD,EAKhD,QALgD,EAMhD,KANgD,EAOhD,iBAPgD,EAQhD,UARgD,CAAR,CAA1C;AAWA,UAAMhB,QAAQ,GACZiB,SAAS,CAACG,EAAV,KAAiBnB,SAAjB,GACIP,WAAW,CACTuB,SAAS,CAACG,EADD,EAETH,SAAS,CAACI,eAAV,GAA4BpB,SAA5B,GAAwCgB,SAAS,CAACrB,MAFzC,CADf,GAKI0B,cANN;AAQA,UAAMC,YAAY,GAAGxB,UAAU,CAAC;;;AAC9B,YAAMyB,SAAS,2BAAGP,SAAS,CAACO,SAAb,uEAA0B,EAAzC;;AACA,UAAIP,SAAS,CAACQ,IAAV,KAAmBxB,SAAnB,IAAgCgB,SAAS,CAACS,GAA9C,EAAmD;AACjDF,QAAAA,SAAS,CAACb,kBAAD,CAAT,GAAgCX,QAAQ,EAAxC;AACA,eAAOwB,SAAP;AACD;;AACD,aAAOA,SAAP;AACD,KAP8B,CAA/B;AASA,UAAMG,OAAO,GAA6B5B,UAAU,CAAC;AACnD,UAAIkB,SAAS,CAACQ,IAAV,KAAmBxB,SAAvB,EAAkC;AAChC,YAAI;AACF,iBAAOc,OAAO,CAACa,SAAR,CACLrB,eAAe,CAACU,SAAS,CAACG,EAAX,CADV,EAELH,SAAS,CAACrB,MAFL,CAAP;AAID,SALD,CAKE,OAAOiC,GAAP,EAAY;AACZC,UAAAA,OAAO,CAACC,IAAR,CAAa,0BAAb,EAAyCF,GAAzC;AACD;AACF;;AACD,aAAO5B,SAAP;AACD,KAZmD,CAApD;AAcA,WAAO,MACLgB,SAAS,CAACe,QAAV;AAAA;;AAAA,mBAESd,UAFT;;AAAA,oCAIeK,YAAY,EAJ3B;;AAAA;AAAA;AAAA;;AAAA,sBAWcU,EAAD;;;AACPA,QAAAA,EAAE,CAACC,cAAH;;AACA,gBAAQlB,KAAK,CAACS,IAAd;AACE,eAAKxB,SAAL;AACEc,YAAAA,OAAO,CAACoB,QAAR,CACE5B,eAAe,CAACU,SAAS,CAACG,EAAX,CADjB,uBAEEH,SAAS,CAACrB,MAFZ,iEAEsB,EAFtB;AAIA,gBAAI,OAAOqB,SAAS,CAACmB,OAAjB,KAA6B,UAAjC,EACEnB,SAAS,CAACmB,OAAV,CAAkBH,EAAlB;AACF;;AACF,eAAK3B,OAAO,CAAC+B,IAAb;AACEC,YAAAA,MAAM,CAACC,OAAP,CAAeC,IAAf;AACA;;AACF,eAAKlC,OAAO,CAAC+B,IAAb;AACEC,YAAAA,MAAM,CAACC,OAAP,CAAeC,IAAf;AACA;AAdJ;;AAgBAP,QAAAA,EAAE,CAACQ,MAAH,CAAUC,IAAV;AACD,OA9BL;;AAAA,oBAQSxB,UART;;AAAA;AAAA,oBASeK,YAAY,EAT3B;AAAA,qBAUUI,OAAO,EAVjB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,QADF;AAkCD,GA7ED;AA8ED;;AAED,MAAML,cAAc,GAAG,MAAM,KAA7B;;;;ACvJA,MAAMqB,YAAY,GAAGjE,aAAa,CAAS,EAAT,CAAlC;;AA8BA,SAASkE,SAAT,CACEC,GADF,EAEEzC,IAFF,EAGEY,KAHF;AAKE,QAAM8B,MAAM,GAAG9B,KAAK,CAAC+B,IAAN,KAAe9C,SAAf,GAA2Be,KAAK,CAAC+B,IAAjC,GAAwC/B,KAAK,CAACgC,MAA7D;AACA,QAAMC,KAAK,GAAGjC,KAAK,CAAC+B,IAAN,KAAe9C,SAA7B;AACA,QAAMwC,MAAM,GAAGI,GAAG,KAAK,EAAR,MAAgBA,OAAOC,QAAvB,GAAkCA,MAAjD;AACA,SAAO,CAACL,MAAD,EAASQ,KAAK,GAAG7C,IAAI,KAAKqC,MAAZ,GAAqBrC,IAAI,CAAC8C,UAAL,CAAgBT,MAAhB,CAAnC,CAAP;AACD;AAED;;;;;;;SAKgBU,aAAanC;AAI3B,QAAM6B,GAAG,GAAGjE,UAAU,CAAC+D,YAAD,CAAtB;AACA,QAAMnC,KAAK,GAAGxB,eAAe,EAA7B;AACA,QAAMoE,QAAQ,GAAGrD,UAAU,CACzB;AACE,UAAMK,IAAI,GAAGI,KAAK,EAAlB;AACA,UAAM6C,QAAQ,GAAGrC,KAAK,CAACqC,QAAvB;;AACA,SAAK,IAAIhD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgD,QAAQ,CAAC5D,MAA7B,EAAqCY,CAAC,EAAtC,EAA0C;AACxC,YAAM,CAACoC,MAAD,EAASa,IAAT,IAAiBV,SAAS,CAACC,GAAD,EAAMzC,IAAN,EAAYiD,QAAQ,CAAChD,CAAD,CAApB,CAAhC;AACA,UAAIiD,IAAJ,EAAU,OAAO,CAACjD,CAAD,EAAIoC,MAAJ,CAAP;AACX;;AACD,WAAOxC,SAAP;AACD,GATwB,EAUzBA,SAVyB,EAWzB,CAACd,CAAD,EAAIC,CAAJ;AACE,UAAMmE,IAAI,GACRpE,CAAC,KAAKC,CAAN,IAAYD,CAAC,KAAKc,SAAN,IAAmBb,CAAC,KAAKa,SAAzB,IAAsCd,CAAC,CAAC,CAAD,CAAD,KAASC,CAAC,CAAC,CAAD,CAD9D;AAEA,WAAOmE,IAAP;AACD,GAfwB,CAA3B;AAiBA,SAAOxD,UAAU,CAAC;AAChB,UAAMyD,EAAE,GAAGJ,QAAQ,EAAnB;;AACA,QAAII,EAAE,KAAKvD,SAAX,EAAsB;AACpB,YAAM,CAACI,CAAD,EAAIoC,MAAJ,IAAce,EAApB;AACA;AAAA,eACgCf,MADhC;;AAAA;AAAA,iBAEKzB,KAAK,CAACqC,QAAN,CAAehD,CAAf,EAAkBgD,QAFvB;AAAA;;AAAA;AAKD;;AACD,WAAOrC,KAAK,CAACyC,QAAb;AACD,GAXgB,CAAjB;AAYD;AAID;;;;SAGgBC,UAAU1C;AACxB,QAAM2C,QAAQ,GAAGC,cAAc,CAAC5C,KAAD,CAA/B;AACA,SAAO;AACL,UAAM,CAACyB,MAAD,EAASa,IAAT,IAAiBK,QAAQ,EAA/B;AACA;AAAA,YACcL,IADd;;AAAA;AAAA,eAC8BtC,KAAK,CAACyC,QADpC;AAAA;;AAAA;AAAA;AAAA,iBAEkChB,MAFlC;;AAAA;AAAA,mBAGOzB,KAAK,CAACqC,QAHb;AAAA;;AAAA;AAAA;;AAAA;AAOD,GATD;AAUD;AAED;;;;SAGgBQ,WAAW7C;AACzB,QAAM2C,QAAQ,GAAGC,cAAc,CAAC5C,KAAD,CAA/B;AACA;AAAA;AAAA,aACe2C,QAAQ,GAAG,CAAH,CADvB;AAAA;;AAAA;AAAA;AAAA;AAAA,iBAEkCA,QAAQ,GAAG,CAAH,CAF1C;AAAA;;AAAA;AAAA,iBAGO3C,KAAK,CAACqC,QAHb;AAAA;;AAAA;AAAA;;AAAA;AAOD;;AAED,SAASO,cAAT,CAAwB5C,KAAxB;AACE,QAAMR,KAAK,GAAGxB,eAAe,EAA7B;AACA,QAAM6D,GAAG,GAAGjE,UAAU,CAAC+D,YAAD,CAAtB;AACA,SAAO5C,UAAU,CACf,MAAM6C,SAAS,CAACC,GAAD,EAAMrC,KAAK,EAAX,EAAeQ,KAAf,CADA,EAEff,SAFe,EAGf,CAACd,CAAD,EAAIC,CAAJ,KAAUD,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAD,KAASC,CAAC,CAAC,CAAD,CAHV,CAAjB;AAKD;;ACnHD;;;;;;;;SAOwB0E,kBAGtBC,MAASC;AACT,QAAMjF,YAAY,GAAGD,YAAY,EAAjC;;AAEA,WAASmF,eAAT,CACEC,KADF,EAEEC,KAFF,EAGEC,MAHF,EAIEC,YAJF;AAME,UAAMC,OAAO,GAAGD,YAAH,aAAGA,YAAH,cAAGA,YAAH,GAAoB,EAAjC;AACA,UAAM,CAACE,KAAD,EAAQC,QAAR,IAAoBC,WAAW,CAACH,OAAD,CAArC;AAEA,UAAMI,aAAa,GAAG3E,UAAU,CAC9B,MAAMhB,YAAY,GAAG4F,KAAf,CAAqBT,KAAK,CAACzE,MAA3B,CADwB,EAE9B,EAF8B,EAG9B,CAACN,CAAD,EAAIC,CAAJ;AACE,UAAID,CAAC,KAAKC,CAAV,EAAa,OAAO,IAAP;AACb,UAAID,CAAC,CAACM,MAAF,KAAaL,CAAC,CAACK,MAAnB,EAA2B,OAAO,KAAP;;AAC3B,WAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,CAAC,CAACM,MAAtB,EAA8BY,CAAC,EAA/B,EAAmC;AACjC,cAAMuE,CAAC,GAAGzF,CAAC,CAACkB,CAAD,CAAX;AACA,cAAMwE,CAAC,GAAGzF,CAAC,CAACiB,CAAD,CAAX;AACA,YAAIuE,CAAC,KAAKC,CAAV,EAAa,OAAO,KAAP;AACd;;AACD,aAAO,IAAP;AACD,KAZ6B,CAAhC;;AAeA,aAASC,QAAT,CACE/B,IADF,EAEEgC,IAFF,EAGEC,IAHF,EAIEC,OAJF;AAME,WAAK,MAAM1F,GAAX,IAAkBwF,IAAlB,EAAwB;AACtB,cAAMG,EAAE,GAAIH,IAAwB,CAACxF,GAAD,CAApC;;AACA,YAAI,OAAO2F,EAAP,KAAc,UAAlB,EAA8B;AAC5B,gBAAMC,KAAK,GAAGD,EAAE,EAAhB;AACA,cAAIC,KAAK,KAAMZ,KAAe,CAAChF,GAAD,CAA9B,EAAoD;AACpDyF,UAAAA,IAAI,CAACzF,GAAD,CAAJ,GAA2B4F,KAA3B;AACAF,UAAAA,OAAO,CAACG,OAAR;AACA;AACD;;AACD,YAAIF,EAAE,KAAKjF,SAAX,EAAsB;AACpB,cAAI8C,IAAI,CAAC,CAAD,CAAJ,KAAYxD,GAAhB,EAAqB;AACnBuF,YAAAA,QAAQ,CAAC/B,IAAI,CAAC4B,KAAL,CAAW,CAAX,CAAD,EAAgBO,EAAhB,EAA2BF,IAA3B,EAAiCC,OAAjC,CAAR;AACD;AACF;AACF;AACF;;AAEDI,IAAAA,cAAc,CAAC;AACb,YAAMvC,MAAM,GAAG4B,aAAa,EAA5B;AACAY,MAAAA,OAAO,CAAC;AACN,cAAMN,IAAI,GAAmB,EAAE,GAAIT;AAAN,SAA7B;AACA,cAAMU,OAAO,GAAG;AAAEG,UAAAA,OAAO,EAAE;AAAX,SAAhB;AACAN,QAAAA,QAAQ,CAAChC,MAAD,EAASqB,KAAT,EAAgBa,IAAhB,EAAsBC,OAAtB,CAAR;;AACA,YAAIA,OAAO,CAACG,OAAR,GAAkB,CAAtB,EAAyB;AACvBZ,UAAAA,QAAQ,CAACQ,IAAD,CAAR;AACD;AACF,OAPM,CAAP;AAQD,KAVa,CAAd;AAYA,WAAOO,iBAAe,CAACnB,MAAD,EAASG,KAAT,CAAtB;AACD;;AAED,WAASiB,QAAT,CACEzC,IADF,EAEEgC,IAFF;AAIE,QAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;AAC9B,aAAOA,IAAI,CAAC,UAAiBU,KAAjB;AACV,cAAM;AAAEzE,UAAAA,KAAF;AAAS0E,UAAAA,MAAT;AAAiBrB,UAAAA;AAAjB,YAAkCoB,KAAxC;AACA,eAAO,MAAMxB,eAAe,CAAClB,IAAD,EAAO/B,KAAP,EAAc0E,MAAd,EAAsBrB,YAAtB,CAA5B;AACD,OAHU,CAAX;AAID;;AAED,UAAMhB,QAAQ,GAAsB,EAApC;AACA,UAAM;AAAEqC,MAAAA,MAAM,EAAEC,UAAU,GAAGC,QAAvB;AAAiCnC,MAAAA,QAAjC;AAA2C,SAAGoC;AAA9C,QAAyDd,IAA/D;;AACA,SAAK,MAAMxF,GAAX,IAAkBsG,MAAlB,EAA0B;AACxB,YAAMb,IAAI,GAAG,CAAC,GAAGjC,IAAJ,EAAUxD,GAAV,CAAb;AACA,YAAMuG,KAAK,GAAGD,MAAM,CAACtG,GAAD,CAApB;AACA8D,MAAAA,QAAQ,CAAC0C,IAAT,CAAc;AACZ/C,QAAAA,MAAM,EAAEzD,GADI;AAEZ8D,QAAAA,QAAQ,EAAEmC,QAAQ,CAACR,IAAD,EAAOc,KAAP;AAFN,OAAd;AAID;;AAED,WAAO;AAAA;AAAA;AAAA,oBAEqBrC,QAFrB;AAAA,oBAEyCJ;AAFzC;AAAA;;AAAA,MAAP;AAKD;;AAED,SAAOiC,OAAO,CAAC,MAAME,QAAQ,CAAC,EAAD,EAAKzB,IAAL,CAAf,CAAd;AACD;AA+CD;;;;;SAIgB6B,SAAY5E;AAC1B,SAAOA,KAAK,CAACqC,QAAb;AACD;;ACvHD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA6BwB2C,kBAItBH,QACA;AAAEI,EAAAA,aAAF;AAAiBC,EAAAA,OAAjB;AAA0BvG,EAAAA,IAAI,EAAEwG;AAAhC;AAgCA,QAAM,CAACpF,OAAD,EAAUqF,MAAV,IAAoB,CAAC;AACzB,QAAIrF,OAAJ;AACA,QAAIqF,MAAJ;AACA,UAAMC,CAAC,GAAGJ,aAAa,CAAEJ,MAAF,CAAvB;;AACA,QAAIS,KAAK,CAACC,OAAN,CAAcF,CAAd,CAAJ,EAAsB;AACpB,OAACtF,OAAD,EAAU,GAAGqF,MAAb,IAAuBC,CAAvB;AACD,KAFD,MAEO;AACLtF,MAAAA,OAAO,GAAGsF,CAAV;AACAD,MAAAA,MAAM,GAAG,EAAT;AACD;;AACD,WAAO,CAACrF,OAAD,EAAUqF,MAAV,CAAP;AACD,GAXyB,GAA1B;;;AAcA,QAAMvF,IAAI,GAAoC;AAAEgF,IAAAA,MAAF;AAAU9E,IAAAA;AAAV,GAA9C;AACAzB,EAAAA,MAAM,CAACkH,MAAP,CAAc3F,IAAd;AAEA,SAAO;AACL4F,IAAAA,IAAI,EAAE7F,UAAU,CAACC,IAAD,EAAOsF,UAAP,CADX;;AAGLO,IAAAA,MAAM,CAAC1F,KAAD;AACJ,aAAO8C,iBAAiB,CACtB9C,KAAK,CAACqC,QADgB,EAEtBrC,KAAK,CAAC2F,MAFgB,CAAxB;AAID,KARI;;AAULC,IAAAA,QAAQ,CAAC5F,KAAD;;;AACN,YAAM6F,YAAY,wBAAG9F,OAAO,CAAC+F,QAAR,EAAH,iEAAyB;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAA3C;AACA,YAAM,CAAClI,QAAD,EAAWmI,QAAX,IAAuBC,YAAY,CAAaJ,YAAb,CAAzC;AAEA,YAAM9H,YAAY,GAAGgB,UAAU,CAC7B,MAAMlB,QAAQ,GAAGkI,IADY,EAE7BF,YAAY,CAACE,IAFgB,EAG7B,CAAC5H,CAAD,EAAIC,CAAJ,KAAUD,CAAC,KAAKC,CAHa,CAA/B;AAMA,YAAM8H,iBAAiB,GAAGnH,UAAU,CAClC,MAAMT,MAAM,CAACkH,MAAP,CAAczH,YAAY,GAAGoI,KAAf,CAAqB,GAArB,CAAd,CAD4B,EAElCN,YAAY,CAACE,IAAb,CAAkBI,KAAlB,CAAwB,GAAxB,CAFkC,CAApC;AAKA,YAAMhC,KAAK,GAAG;AACZtG,QAAAA,QADY;AAEZE,QAAAA,YAAY,EAAEmI,iBAFF;AAGZjI,QAAAA,eAAe,EAAEF,YAHL;AAIZqI,QAAAA,MAAM,EAAEvG;AAJI,OAAd;AAOAwG,MAAAA,YAAY,CAAC;AACXtG,QAAAA,OAAO,CAACuG,SAAR,CAAmB/C,KAAD,IAAWyC,QAAQ,CAAC1H,MAAM,CAACkH,MAAP,CAAcjC,KAAK,CAAC/D,KAApB,CAAD,CAArC;AACAO,QAAAA,OAAO,CAACwG,KAAR;AACA,YAAI,OAAOrB,OAAP,KAAmB,UAAvB,EAAmCA,OAAO,CAACnF,OAAD,CAAP;AACpC,OAJW,CAAZ;AAMAyG,MAAAA,SAAS,CAAC;AACR,aAAK,MAAMC,KAAX,IAAoBrB,MAApB,EAA4B;AAC1BqB,UAAAA,KAAK;AACN;;AACD1G,QAAAA,OAAO,CAAC2G,IAAR;AACD,OALQ,CAAT;AAOA;AAAA,eAC2BvC,KAD3B;;AAAA;AAAA,iBACmCnE,KAAK,CAACqC,QADzC;AAAA;;AAAA;AAGD,KAhDI;;AAiDL+D,IAAAA,MAAM,EAAEvG,IAjDH;AAkDL8G,IAAAA,KAAK,EAAE;AAlDF,GAAP;AAoDD;;;;;"}