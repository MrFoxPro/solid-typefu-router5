{"version":3,"file":"index.es.js","sources":["../src/context.ts","../src/components/Link.tsx","../src/components/MatchRoute.tsx","../src/components/RouteTree.tsx","../src/index.tsx"],"sourcesContent":["import { createContext, useContext, createMemo } from 'solid-js';\nimport { RouterContextValue } from './types';\nimport { State as RouteState } from 'router5';\nimport { RouteLike } from 'components/Link';\n\nconst Context = createContext<RouterContextValue>();\n\nexport default Context;\n\nexport function useRoute(): () => RouteState {\n  return useContext(Context).getRoute;\n}\n\nexport function useRouteName(): () => readonly string[] {\n  return useContext(Context).getRouteName;\n}\n\nexport function useRouteNameRaw(): () => string {\n  return useContext(Context).getRouteNameRaw;\n}\n\nfunction shallowStringyEq<\n  A extends Record<string, any>,\n  B extends Record<string, any>\n>(a: A, b: B): boolean {\n  if (a === b) return true;\n  const keys = Object.keys(a);\n  for (const key of keys) if (!(key in b)) return false;\n  for (const key of keys) if (String(a[key]) !== String(b[key])) return false;\n  return keys.length === Object.keys(b).length;\n}\n\nexport function useIsActive<Link extends RouteLike>(\n  link: Link,\n  params?: Record<string, any>,\n  isEqual: <A extends Record<string, any>, B extends Record<string, any>>(a: A, b: B) => boolean = shallowStringyEq,\n): () => boolean {\n  const getRouteName = useRouteName();\n  const getIsActiveByName = createMemo(() => isActive(getRouteName(), link));\n  if (params === undefined) return getIsActiveByName;\n  const getRoute = useRoute();\n  const getRouteParams = createMemo(() => getRoute().params);\n  return createMemo(() => {\n    const routeParams = getRouteParams();\n    return getIsActiveByName() && isEqual(routeParams, params);\n  });\n}\n\n/**\n * Find whether 'link' is an ancestor of, or equal to, 'here'\n *\n * Maybe useful for creating your own `Link` component.\n */\nexport function isActive<Link extends RouteLike>(here: readonly string[], link: Link) {\n  if (here.length === 0) { return false; }\n  if (typeof link === 'string') { return here[0] === link; }\n  // if link has more segments than here then it definitely cannot be an\n  // ancestor of here\n  if (link.length > here.length) return false;\n  for (let i = 0; i < link.length; i ++) {\n    if (link[i] !== here[i]) return false;\n  }\n  return true;\n}\n","import { SharedRouterValue, RoutesLike } from '../types';\nimport { useIsActive } from '../context';\nimport { createMemo } from 'solid-js';\n\nexport enum LinkNav { Back, Forward };\n\n/** Props for making a `Link` component.\n *\n * @remarks\n *\n * Only some of the props are reactive; the rest are static at the time of\n * creating the link. The reactive props available are:\n *\n * - `to`\n * - `params`\n * - `disabled`\n * - `onClick`\n * - `innerProps`\n * - `disabledProps`\n */\nexport type LinkProps<Route> = {\n  disabled?: boolean,\n  nav?: boolean,\n  navIgnoreParams?: boolean,\n  onClick?: (ev: MouseEvent & {\n    target: HTMLAnchorElement,\n    currentTarget: HTMLAnchorElement,\n  }) => void,\n} & ({\n  type: LinkNav.Back | LinkNav.Forward\n  to?: undefined,\n  params?: undefined,\n} | {\n  type?: undefined,\n  to: Route,\n  params?: Record<string, any>,\n}) &\n  Omit<JSX.IntrinsicElements['a' | 'button'], 'onClick' | 'href' | 'type'>\n  ;\n\nexport interface LinkConfig {\n  navActiveClassName: string,\n}\n\nexport type RouteLike = string | string[];\n\nexport function renderRouteLike(route: RouteLike) {\n  if (typeof route === 'string') return route;\n  return route.join('.');\n}\n\nexport const defaultLinkConfig: LinkConfig = {\n  navActiveClassName: 'is-active',\n};\n\nexport default function createLink<Deps, Routes extends RoutesLike<Deps>, RouteName extends RouteNameOf<Routes> & RouteLike>(\n  self: SharedRouterValue<Deps, Routes>,\n  config: Partial<LinkConfig> = defaultLinkConfig,\n): (props: LinkProps<RouteName>) => JSX.Element {\n\n  const { router5 } = self;\n\n  const {\n    navActiveClassName = defaultLinkConfig.navActiveClassName,\n  } = config;\n\n  return (props: LinkProps<RouteName>): JSX.Element => {\n    const isActive = props.to !== undefined ?\n      useIsActive(props.to, props.navIgnoreParams ? undefined : props.params) :\n      alwaysInactive;\n\n    const getClassList = createMemo(() => {\n      const classList = props.classList ?? {};\n      if (props.type === undefined && props.nav) {\n        classList[navActiveClassName] = isActive();\n        return classList;\n      }\n      return classList;\n    });\n\n    const getInnerProps = createMemo(() => {\n      const {classList: _cl, onClick: _oc, ...innerProps} = props;\n      return innerProps;\n    });\n\n    const getHref: () => string | undefined = createMemo(() => {\n      if (props.type === undefined) {\n        try {\n          return router5.buildPath(renderRouteLike(props.to), props.params);\n        } catch (err) {\n          console.warn('<Link> buildPath failed:', err);\n        }\n      }\n      return undefined;\n    });\n\n    return () => props.disabled ?\n      <button\n        {...getInnerProps() as JSX.IntrinsicElements['button']}\n        disabled\n        classList={getClassList()}\n      /> :\n      <a\n        {...getInnerProps() as JSX.IntrinsicElements['a']}\n        classList={getClassList()}\n        href={getHref()}\n        onClick={(ev) => {\n          ev.preventDefault();\n          switch (props.type) {\n            case undefined:\n              router5.navigate(renderRouteLike(props.to as RouteLike), props.params ?? {});\n              if (typeof props.onClick === 'function') props.onClick(ev);\n              break;\n            case LinkNav.Back:\n              window.history.back();\n              break;\n            case LinkNav.Back:\n              window.history.back();\n              break;\n          }\n          ev.target.blur();\n        }}\n      />;\n  };\n}\n\nconst alwaysInactive = () => false;\n\n// Beware, here be dragons\nexport type RouteNameOf<A> = UnOne<Undefer<Flatten<TreeOf<A>, []>>>;\n\ntype TreeOf<A> =\n  A extends readonly (infer U)[]\n    ? U extends { name: infer Name, children: infer Children }\n      ? Children extends {}\n        ? [Name] | [Name, TreeOf<Children>]\n        : Name\n    : U extends { name: infer Name }\n      ? [Name]\n      : never\n  : never;\n\ntype UnOne<A> = A extends [infer U] ? U : A;\n\n// This is what requires typescript 4.0+\ntype Flatten<Arg, Acc extends any[]> =\n  Arg extends [infer X]\n  ? [...Acc, X]\n  : Arg extends [infer X, infer XS]\n    ? Defer<Flatten<XS, [...Acc, X]>>\n    : never;\n\n// Same trick as in https://github.com/microsoft/TypeScript/pull/21613\ninterface Defer<X> { self: Undefer<X> }\ntype Undefer<X> = X extends { self: infer U } ? U : X;\n","import { createContext, useContext, Match, Show, createMemo } from \"solid-js\";\nimport { useRouteNameRaw } from \"../context\";\n\nconst MatchContext = createContext<string>(\"\");\n\nexport type MatchRouteProps = PathProps & { children: JSX.Element };\n\nexport interface ExactPathProps {\n  path: string;\n  prefix?: undefined;\n}\n\nexport interface PrefixPathProps {\n  prefix: string;\n  path?: undefined;\n}\n\n/**\n * ```ts\n * type PathProps = { path: string } | { prefix: string };\n * ```\n *\n * If [[ExactPathProps.path]] is given, then the match is exact, which means\n * that the current route name must be equal to `context.path + path` where\n * `context.path` means the current path created by other match components above\n * this one.\n *\n * If [[PrefixPathProps.prefix]] is given, then the match only requires that the\n * current route start with `context.path + prefix`.\n *\n */\nexport type PathProps = ExactPathProps | PrefixPathProps;\n\nfunction doesMatch(\n  ctx: string,\n  here: string,\n  props: PathProps\n): [string, boolean] {\n  const suffix = props.path !== undefined ? props.path : props.prefix;\n  const exact = props.path !== undefined;\n  const target = ctx !== \"\" ? `${ctx}.${suffix}` : suffix;\n  return [target, exact ? here === target : here.startsWith(target)];\n}\n\n/**\n * Not reactive on the routes being used\n *\n * Prefer this over [[Switch]] + [[MatchRoute]]\n */\nexport function SwitchRoutes(props: {\n  children: MatchRouteProps[];\n  fallback?: JSX.Element;\n}): JSX.Element {\n  const ctx = useContext(MatchContext);\n  const route = useRouteNameRaw();\n  const getIndex = createMemo<undefined | [number, string]>(\n    () => {\n      const here = route();\n      const children = props.children;\n      for (let i = 0; i < children.length; i++) {\n        const [target, when] = doesMatch(ctx, here, children[i]);\n        if (when) return [i, target];\n      }\n      return undefined;\n    },\n    undefined,\n    (a, b) => {\n      const same =\n        a === b || (a !== undefined && b !== undefined && a[0] === b[0]);\n      return same;\n    }\n  );\n  return createMemo(() => {\n    const ix = getIndex();\n    if (ix !== undefined) {\n      const [i, target] = ix;\n      return (\n        <MatchContext.Provider value={target}>\n          {props.children[i].children}\n        </MatchContext.Provider>\n      );\n    }\n    return props.fallback;\n  });\n}\n\nexport type ShowRouteProps = MatchRouteProps & { fallback?: JSX.Element };\n\n/**\n * Create a [[Show]] node against a given route.\n */\nexport function ShowRoute(props: ShowRouteProps): JSX.Element {\n  const getMatch = createGetMatch(props);\n  return () => {\n    const [target, when] = getMatch();\n    return (\n      <Show when={when} fallback={props.fallback}>\n        <MatchContext.Provider value={target}>\n          {props.children}\n        </MatchContext.Provider>\n      </Show>\n    );\n  };\n}\n\n/**\n * Create a [[Match]] node against a given route.\n */\nexport function MatchRoute(props: MatchRouteProps): JSX.Element {\n  const getMatch = createGetMatch(props);\n  return (\n    <Match when={getMatch()[1]}>\n      <MatchContext.Provider value={getMatch()[0]}>\n        {props.children}\n      </MatchContext.Provider>\n    </Match>\n  );\n}\n\nfunction createGetMatch(props: PathProps): () => [string, boolean] {\n  const route = useRouteNameRaw();\n  const ctx = useContext(MatchContext);\n  return createMemo<[string, boolean]>(\n    () => doesMatch(ctx, route(), props),\n    undefined,\n    (a, b) => a && a[1] === b[1]\n  );\n}\n","import { UnionToIntersection } from \"ts-essentials\";\nimport {\n  createState,\n  createSignal,\n  createEffect,\n  createMemo,\n  untrack,\n} from \"solid-js\";\nimport { useRouteName } from \"../context\";\nimport { MatchRouteProps, SwitchRoutes } from \"./MatchRoute\";\nimport { RouteLike } from \"./Link\";\n\n/**\n * Given a tree of routes and render instructions for each route, return an\n * element that selects the correct renderer for the current route.\n *\n * Also supports using routes to choose how to provide props to a single\n * renderer.\n */\nexport default function RouteStateMachine<\n  T extends RenderTreeLike,\n  A extends RouteLike\n>(tree: T, _assumed?: A): JSX.Element {\n  const getRouteName = useRouteName();\n\n  function traverseHydrate<Props>(\n    path0: string[],\n    node0: GetPropsLike<Props>,\n    Render: (props: Props) => JSX.Element,\n    defaultGetProps: undefined | GetProps<Props>,\n    defaultProps: undefined | Props\n  ): JSX.Element {\n    const [populated, setPopulated] = createSignal(false);\n    const [state, setState] = createState<Props>(defaultProps ?? ({} as Props));\n\n    const getPathSuffix = createMemo<string[]>(\n      () => getRouteName().slice(path0.length),\n      [],\n      (a, b) => {\n        if (a === b) return true;\n        if (a.length !== b.length) return false;\n        for (let i = 0; i < a.length; i++) {\n          const x = a[i];\n          const y = b[i];\n          if (x !== y) return false;\n        }\n        return true;\n      }\n    );\n\n    function populate(\n      path: string[],\n      node: GetPropsLike<Props>,\n      next: Partial<Props>,\n      counter: { populated: number; updated: number }\n    ) {\n      for (const key in node) {\n        const gp = (node as GetProps<Props>)[key as keyof Props];\n        if (typeof gp === \"function\") {\n          const value = gp();\n          counter.populated++;\n          if (value === (state as Props)[key as keyof Props]) continue;\n          next[key as keyof Props] = value;\n          counter.updated++;\n          continue;\n        }\n        if (gp !== undefined) {\n          if (path[0] === key) {\n            populate(path.slice(1), gp as any, next, counter);\n          }\n        }\n      }\n    }\n\n    function populateFromDefaultGetProps(\n      next: Partial<Props>,\n      counter: { populated: number; updated: number }\n    ) {\n      if (defaultGetProps === undefined) {\n        return;\n      }\n      for (const k_ in defaultGetProps) {\n        const k: keyof Props = k_;\n        if (next[k] === undefined) {\n          const fn = defaultGetProps[k];\n          if (typeof fn === \"function\") {\n            const value = fn();\n            counter.populated++;\n            if (value !== next[k as keyof Props]) {\n              next[k as keyof Props] = value;\n              counter.updated++;\n            }\n          }\n        }\n      }\n    }\n\n    createEffect(() => {\n      const suffix = getPathSuffix();\n      untrack(() => {\n        const next: Partial<Props> = { ...(state as Props) };\n        const counter = { populated: 0, updated: 0 };\n        populate(suffix, node0, next, counter);\n        populateFromDefaultGetProps(next, counter);\n        if (counter.updated > 0) {\n          setState(next);\n        }\n        setPopulated(true);\n      });\n    });\n\n    return () => {\n      return populated() ? <Render {...(state as Props)} /> : undefined;\n    };\n  }\n\n  function traverse(\n    path: string[],\n    node: RenderTreeOf<RouteTreeLike>\n  ): JSX.Element {\n    if (typeof node === \"function\") {\n      return node(function <Props>(owned: OwnedOps<RouteTreeLike, Props>) {\n        const { props, render, defaultGetProps, defaultProps } = owned;\n        return traverseHydrate(\n          path,\n          props,\n          render,\n          defaultGetProps,\n          defaultProps\n        );\n      });\n    }\n\n    const children: MatchRouteProps[] = [];\n    const { render: RenderHere = passthru, fallback, ...routes } = node;\n    for (const key in routes) {\n      const next = [...path, key];\n      const child = routes[key]!;\n      children.push({\n        prefix: key,\n        children: traverse(next, child),\n      });\n    }\n\n    return () => (\n      <RenderHere>\n        <SwitchRoutes fallback={fallback} children={children} />\n      </RenderHere>\n    );\n  }\n\n  return untrack(() => traverse([], tree as RenderTreeOf<RouteTreeLike>));\n}\n\n/**\n * Tells `solid-typefu-router5` how to render a node if the path leading to\n * it matches the current route name.\n */\nexport interface RenderNode {\n  /** Default: [[passthru]] */\n  render?: (props: { children?: JSX.Element }) => JSX.Element;\n  /** Fallback children to use if none are available to give to [[render]]. Default: nothing */\n  fallback?: JSX.Element;\n}\n\nexport interface OwnedOps<Tree, Props> {\n  /**\n   * @remarks If this has a concrete type for its props then TypeScript will be\n   * able to infer the structure of [[props]].\n   */\n  render: (props: Props) => JSX.Element;\n\n  /**\n   * Default prop values for when no matches are found. Props that are optional\n   * should be typed as such within [[Props]] itself.\n   */\n  defaultProps?: Props;\n\n  /**\n   * Default prop values for when no matches are found. Props that are optional\n   * should be typed as such within [[Props]] itself.\n   */\n  defaultGetProps?: GetProps<Props>;\n\n  /**\n   * A tree of route paths and prop getters. A prop getter is a function of type\n   * `() => PropValue`. The key of the getter determines what prop it gets, and\n   * the type of that prop.\n   *\n   * The tree can go as deep as [[Tree]] will allow for, with each non-function\n   * key corresponding to a path segment in a route.\n   */\n  props: OwnedBy<Tree, Props>;\n}\n\n/** Turn an object into the same object, but all its properties are optional and\n * made into functions returning their value */\nexport type GetProps<Props> = { [K in keyof Props]?: () => Props[K] };\n\n/** Existential wrapper around [[OwnedOps]] that hides the inner [[Tree]] and\n * [[Props]] types */\nexport type Owned<Tree> = <R>(\n  cont: <Props>(self: OwnedOps<Tree, Props>) => R\n) => R;\n\n/**\n * Helper function. Use this as a [[render]] function to just render the\n * children only.\n */\nexport function passthru<T>(props: { children: T }): T {\n  return props.children;\n}\n\n/** A tree of route path segments. Has the same structure as a\n * [[RenderTreeLike]], but the spine of the tree is fixed to use the given\n * [[Tree]] */\nexport type RenderTreeOf<Tree> =\n  | Owned<Tree>\n  | (RenderNode &\n      UnionToIntersection<\n        Tree extends readonly (infer Node)[]\n          ? Node extends { name: infer Name; children?: infer Children }\n            ? Name extends string | number | symbol\n              ? Children extends {}\n                ? { [K in Name]?: RenderTreeOf<Children> }\n                : { [K in Name]?: Owned<Children> | RenderNode }\n              : never\n            : never\n          : never\n      >);\n\nexport type OwnedBy<Tree, Props> = GetPropsWith<\n  GetProps<Props>,\n  UnionToIntersection<\n    Tree extends readonly (infer Node)[]\n      ? Node extends { name: infer Name; children?: infer Children }\n        ? Name extends string | number | symbol\n          ? Children extends {}\n            ? {\n                [K in Name]?: GetPropsWith<\n                  GetProps<Props>,\n                  OwnedBy<Children, Props>\n                >;\n              }\n            : { [K in Name]?: GetProps<Props> }\n          : never\n        : never\n      : never\n  >\n>;\n\n/**\n * Allows for conflicts between prop names and route names. At runtime what is a\n * prop or not is simply determined by whether it's a function or not.\n */\nexport type GetPropsWith<Props, Tree> = {\n  [K in keyof Props & keyof Tree]: Tree[K] | Props[K];\n} &\n  Omit<{ [K in keyof Props]: Props[K] }, keyof Tree> &\n  Omit<{ [K in keyof Tree]: Tree[K] }, keyof Props>;\n\n// monomorphic (in tree spine) helper types\n\nexport type GetPropsLike<Props> = {\n  [k: string]: GetPropsLike<Props>;\n} & GetProps<Props>;\nexport type RouteNodeLike = { name: string; children?: RouteTreeLike };\nexport type RouteTreeLike = RouteNodeLike[];\nexport type RenderTreeLike =\n  | OwnedLike\n  | (RenderNode & { [k: string]: RenderTreeLike });\nexport type OwnedLike = <R>(cont: <Props>(self: OwnedOpsLike<Props>) => R) => R;\nexport interface OwnedOpsLike<Props> {\n  render: (props: Props) => JSX.Element;\n  defaultProps?: Props;\n  defaultGetProps?: GetProps<Props>;\n  props: GetPropsLike<Props>;\n}\n\nexport type DescendDef<Path, Tree> = Path extends [infer P1, ...infer PS]\n  ? Tree extends readonly (infer Node)[]\n    ? Node extends { name: infer Name; children?: infer Children }\n      ? Name extends P1\n        ? Defer<DescendDef<PS, Children>>\n        : never\n      : never\n    : never\n  : Tree;\n\ntype One<T> = T extends any[] ? T : [T];\nexport type Descend<P, T> = Undefer<DescendDef<One<P>, T>>;\n\n// Same trick as in https://github.com/microsoft/TypeScript/pull/21613\ninterface Defer<X> {\n  ____defer: Undefer<X>;\n}\ntype Undefer<X> = X extends { ____defer: infer U } ? U : X;\n","import { State as RouteState, Router as Router5, Route } from 'router5';\nimport { DefaultDependencies } from 'router5/dist/types/router';\nimport { Unsubscribe } from 'router5/dist/types/base';\nimport { createSignal, createEffect, createMemo, onCleanup } from 'solid-js';\nimport { SharedRouterValue, RoutesLike } from './types';\nimport Context from './context';\nimport createLink, { LinkConfig, LinkProps, RouteLike, RouteNameOf } from './components/Link';\nimport RouteStateMachine, { RenderTreeOf, RenderTreeLike, Descend } from './components/RouteTree';\n\nexport { LinkNav, LinkConfig } from './components/Link';\nexport { MatchRoute, ShowRoute, SwitchRoutes } from './components/MatchRoute';\nexport { passthru } from './components/RouteTree';\nexport { default as Context, useRoute, useRouteName, useIsActive, isActive } from './context';\n\nexport type { MatchRouteProps, ShowRouteProps } from './components/MatchRoute';\nexport type { LinkProps, RouteNameOf } from './components/Link';\nexport type { RenderTreeOf } from './components/RouteTree';\nexport type { RoutesLike, SharedRouterValue, RouterContextValue } from './types';\n\nexport interface Config<Deps> {\n  createRouter5: (routes: Route<Deps>[]) => Router5<Deps> | [Router5<Deps>, ...Unsubscribe[]],\n  onStart?: (router: Router5<Deps>) => void,\n  link?: LinkConfig,\n}\n\n/**\n * Create a router for use in solid-js.\n *\n * I'd recommend putting your router in its own file like './router.ts', then\n * exporting the results of this function, like\n *\n * ```ts\n * import { createRouter, Router as Router5 } from 'router5';\n * import { createSolidRouter } from 'solid-ts-router';\n *\n * const routes = [\n *   ...\n * ] as const;\n *\n * // note the \"as const\" is very important! this causes TypeScript to infer\n * // `routes` as the narrowest possible type.\n *\n * function createRouter5(routes: Route<Deps>[]): Router5 {\n *   return createRouter(...)\n * }\n *\n * function onStart(router: Router5): void {\n *   // initial redirect here\n *   ...\n * }\n *\n * export const { Provider, Link, Router } = createSolidRouter(routes, { createRouter5, onStart });\n * ```\n */\nexport default function createSolidRouter<Routes extends RoutesLike<Deps>, Deps = DefaultDependencies>(\n  routes: Routes,\n  {\n    createRouter5,\n    onStart,\n    link: linkConfig,\n  }: Config<Deps>,\n): {\n  Provider(props: { children: JSX.Element }): JSX.Element,\n\n  /** See [[createLink]] */\n  Link(props: LinkProps<RouteNameOf<Routes>>): JSX.Element,\n\n  /** See [[RouteStateMachine]] */\n  Router<AssumePath extends RouteNameOf<Routes> | [] = []>(props: {\n    children: AssumePath extends [] ? RenderTreeOf<Routes> : RenderTreeOf<Descend<AssumePath, Routes>>,\n    assume?: AssumePath,\n  }): JSX.Element,\n\n  /** Probably don't use this. */\n  router: SharedRouterValue<Deps, Routes>,\n\n  /**\n   * Type hints you can use to give type names to aspects of your router like\n   *\n   * ```typescript\n   * type Hints = typeof hints;\n   * export type RouteName = Hints['name'];\n   * ```\n   */\n  hints: Phantom<{\n    routes: Routes,\n    name: RouteNameOf<Routes>,\n    tree: RenderTreeOf<Routes>\n  }>,\n} {\n\n  const [router5, unsubs] = (() => {\n    let router5: Router5<Deps>;\n    let unsubs: Unsubscribe[];\n    const r = createRouter5(routes as any as Route<Deps>[]);\n    if (Array.isArray(r)) {\n      [router5, ...unsubs] = r;\n    } else {\n      router5 = r;\n      unsubs = [];\n    }\n    return [router5, unsubs] as const;\n  })();\n\n  // yolo, hopefully router5 doesn't actually mutate routes =)\n  const self: SharedRouterValue<Deps, Routes> = { routes, router5 };\n  Object.freeze(self);\n\n  return {\n    Link: createLink(self, linkConfig),\n\n    Router(props) {\n      return RouteStateMachine(props.children as RenderTreeLike, props.assume as RouteLike);\n    },\n\n    Provider(props: { children: JSX.Element }): JSX.Element {\n      const initialState = router5.getState() ?? { name: '' };\n      const [getRoute, setRoute] = createSignal<RouteState>(initialState);\n\n      const getRouteName = createMemo(() =>\n        getRoute().name, initialState.name, (a, b) => a === b);\n\n      const getSplitRouteName = createMemo(() =>\n        Object.freeze(getRouteName().split('.')), initialState.name.split('.'));\n\n      const value = {\n        getRoute,\n        getRouteName: getSplitRouteName,\n        getRouteNameRaw: getRouteName,\n        router: self as SharedRouterValue<unknown, unknown>,\n      };\n\n      createEffect(() => {\n        router5.subscribe(state => setRoute(Object.freeze(state.route)));\n        router5.start();\n        if (typeof onStart === 'function') onStart(router5);\n      });\n\n      onCleanup(() => {\n        for (const unsub of unsubs) { unsub(); }\n        router5.stop();\n      });\n\n      return (\n        <Context.Provider value={value}>\n          {props.children}\n        </Context.Provider>);\n    },\n    router: self,\n    hints: {} as any,\n  };\n}\n\nexport type Phantom<T> = { __phantom__: never } & T;\n\n"],"names":["Context","createContext","useRoute","useContext","getRoute","useRouteName","getRouteName","useRouteNameRaw","getRouteNameRaw","shallowStringyEq","a","b","keys","Object","key","String","length","useIsActive","link","params","isEqual","getIsActiveByName","createMemo","isActive","undefined","getRouteParams","routeParams","here","i","LinkNav","renderRouteLike","route","join","defaultLinkConfig","navActiveClassName","createLink","self","config","router5","props","to","navIgnoreParams","alwaysInactive","getClassList","classList","type","nav","getInnerProps","_cl","onClick","_oc","innerProps","getHref","buildPath","err","console","warn","disabled","ev","preventDefault","navigate","Back","window","history","back","target","blur","MatchContext","doesMatch","ctx","suffix","path","prefix","exact","startsWith","SwitchRoutes","getIndex","children","when","same","ix","fallback","ShowRoute","getMatch","createGetMatch","MatchRoute","RouteStateMachine","tree","_assumed","traverseHydrate","path0","node0","Render","defaultGetProps","defaultProps","populated","setPopulated","createSignal","state","setState","createState","getPathSuffix","slice","x","y","populate","node","next","counter","gp","value","updated","populateFromDefaultGetProps","k_","k","fn","createEffect","untrack","traverse","owned","render","RenderHere","passthru","routes","child","push","createSolidRouter","createRouter5","onStart","linkConfig","unsubs","r","Array","isArray","freeze","Link","Router","assume","Provider","initialState","getState","name","setRoute","getSplitRouteName","split","router","subscribe","start","onCleanup","unsub","stop","hints"],"mappings":"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"}