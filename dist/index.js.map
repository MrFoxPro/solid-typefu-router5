{"version":3,"file":"index.js","sources":["../src/context.ts","../src/components/Link.tsx","../src/components/MatchRoute.tsx","../src/components/RouteTree.tsx","../src/index.tsx"],"sourcesContent":["import { createContext, useContext } from 'solid-js';\nimport { RouterContextValue } from './types';\nimport { State as RouteState } from 'router5';\nimport { RouteLike } from 'components/Link';\n\nconst Context = createContext<RouterContextValue>();\n\nexport default Context;\n\nexport function useRoute(): () => RouteState {\n  return useContext(Context).getRoute;\n}\n\nexport function useRouteName(): () => string[] {\n  return useContext(Context).getRouteName;\n}\n\nexport function useActive<Link extends RouteLike>(link: Link): () => boolean {\n  const getRouteName = useRouteName();\n  return () => isActive(getRouteName(), link);\n}\n\n/**\n * Find whether 'link' is an ancestor of, or equal to, 'here'\n */\nexport function isActive<Route extends RouteLike>(here: string[], link: Route) {\n  // just use join/startsWith? never!! =)\n  if (typeof link === 'string') {\n    let l: string = link;\n    let i: number = 0;\n    for (; i < here.length; i ++) {\n      const seg = here[i];\n      if (seg !== l.slice(0, seg.length) || l[seg.length] !== '.') return false;\n      l = l.slice(0, seg.length + 1);\n    }\n    return link.length <= i;\n  }\n  // if link has more segments than here then it definitely cannot be an\n  // ancestor of here\n  if (link.length > here.length) return false;\n  for (let i = 0; i < link.length; i ++) {\n    if (link[i] !== here[i]) return false;\n  }\n  return true;\n}\n","import { SharedRouterValue, RoutesLike } from '../types';\nimport { isActive, useRouteName } from '../context';\nimport { createMemo } from 'solid-js';\n\nexport enum LinkNav { Back, Forward };\n\n/** Props for making a `Link`\n *\n * @remarks\n *\n * Only some of the props are reactive; the rest are static at the time of\n * creating the link. The reactive props available are:\n *\n * - `to`\n * - `params`\n * - `disabled`\n * - `onClick`\n * - `innerProps`\n * - `disabledProps`\n */\nexport type LinkProps<Route> = {\n  disabled?: boolean,\n  nav?: boolean,\n  onClick?: (ev: MouseEvent & {\n    target: HTMLAnchorElement,\n    currentTarget: HTMLAnchorElement,\n  }) => void,\n} & ({\n  type: LinkNav.Back | LinkNav.Forward\n} | {\n  type?: undefined,\n  to: Route,\n  params?: Record<string, any>,\n}) &\n  Omit<JSX.IntrinsicElements['a' | 'button'], 'onClick' | 'href' | 'type'>\n  ;\n\nexport interface LinkConfig {\n  navActiveClassName: string,\n}\n\nexport type RouteLike = string | string[];\n\nexport function renderRouteLike(route: RouteLike) {\n  if (typeof route === 'string') return route;\n  return route.join('.');\n}\n\nexport const defaultLinkConfig: LinkConfig = {\n  navActiveClassName: 'is-active',\n};\n\nexport default function createLink<Deps, Routes extends RoutesLike<Deps>, RouteName extends RouteNameOf<Routes> & RouteLike>(\n  self: SharedRouterValue<Deps, Routes>,\n  config: Partial<LinkConfig> = defaultLinkConfig,\n): (props: LinkProps<RouteName>) => JSX.Element {\n\n  const { router5 } = self;\n\n  const {\n    navActiveClassName = defaultLinkConfig.navActiveClassName,\n  } = config;\n\n  return (props: LinkProps<RouteName>): JSX.Element => {\n    const getRouteName = useRouteName();\n\n    const getClassList = createMemo(() => {\n      const classList = props.classList ?? {};\n      if (props.type === undefined && props.nav) {\n        classList[navActiveClassName] = isActive(getRouteName(), props.to as RouteLike);\n        return classList;\n      }\n      return classList;\n    });\n\n    const getInnerProps = () => {\n      const {classList: _cl, onClick: _oc, ...innerProps} = props;\n      return innerProps;\n    };\n\n    return () => props.disabled ?\n      <button\n        {...getInnerProps() as JSX.IntrinsicElements['button']}\n        disabled\n        classList={getClassList()}\n      /> :\n      <a\n        {...getInnerProps() as JSX.IntrinsicElements['a']}\n        classList={getClassList()}\n        href={props.type === undefined ?\n          router5.buildPath(renderRouteLike(props.to), props.params) :\n          undefined}\n        onClick={(ev) => {\n          ev.preventDefault();\n          switch (props.type) {\n            case undefined:\n              router5.navigate(renderRouteLike(props.to as RouteLike), props.params ?? {});\n              if (typeof props.onClick === 'function') props.onClick(ev);\n              break;\n            case LinkNav.Back:\n              window.history.back();\n              break;\n            case LinkNav.Back:\n              window.history.back();\n              break;\n          }\n          ev.target.blur();\n        }}\n      />;\n  };\n}\n\n// Beware, here be dragons\n\nexport type RouteNameOf<A> = UnOne<Exp<TreeOf<A>>>;\n\ntype TreeOf<A> =\n  A extends readonly (infer U)[]\n    ? U extends { name: infer Name, children: infer Children }\n      ? Children extends {}\n        ? [Name] | [Name, TreeOf<Children>]\n        : Name\n    : U extends { name: infer Name }\n      ? [Name]\n      : never\n  : never;\n\ntype UnOne<A> = A extends [infer U] ? U : A;\n\n// This is what requires typescript 4.0+\ntype Exp<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, infer XS]\n  ? [X, ...Exp1<XS>] : never;\n\ntype Exp1<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, infer XS]\n  ? [X, ...Exp2<XS>] : never;\n\ntype Exp2<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, infer XS]\n  ? [X, ...Exp3<XS>] : never;\n\ntype Exp3<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, infer XS]\n  ? [X, ...Exp4<XS>] : never;\n\ntype Exp4<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, infer XS]\n  ? [X, ...Exp5<XS>] : never;\n\ntype Exp5<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, infer XS]\n  ? [X, ...Exp6<XS>] : never;\n\ntype Exp6<Arg> = Arg extends [infer X]\n  ? [X] : Arg extends [infer X, any]\n  ? [X, ...never] : never;\n","import { createContext, useContext, Match, Show } from \"solid-js\";\nimport { useRoute } from '../context';\n\nconst MatchContext = createContext<string>('');\n\n/**\n * If `path` is given, then the match is exact, which means that the current\n * route name must be equal to `context.path + path` where `context.path` means\n * the current path created by other match components above this one.\n *\n * If `prefix` is given, then the match only requires that the current route\n * start with `context.path + prefix`.\n */\nexport type MatchRouteProps =\n  ({\n    prefix: string,\n    path?: undefined,\n  } | {\n    prefix?: undefined,\n    path: string,\n  }) & {\n  children: JSX.Element,\n};\n\n/**\n * Match against a given route.\n *\n * @remarks\n * Not reactive with regards to the route being matched.\n */\nexport function MatchRoute(props: MatchRouteProps): JSX.Element {\n  const route = useRoute();\n  const ctx = useContext(MatchContext);\n  const path = props.path !== undefined ? props.path : props.prefix;\n  const exact = props.path !== undefined;\n  const to = ctx !== '' ? `${ctx}.${path}` : path;\n  return () => Match({\n    when: exact ? route().name === to : route().name.startsWith(to),\n    children: MatchContext.Provider({\n      value: to,\n      children: () => props.children,\n    }),\n  });\n}\n\nexport type ShowRouteProps =\n  MatchRouteProps & { fallback?: JSX.Element };\n\nexport function ShowRoute(props: ShowRouteProps): JSX.Element {\n  const route = useRoute();\n  const ctx = useContext(MatchContext);\n  const path = props.path !== undefined ? props.path : props.prefix;\n  const exact = props.path !== undefined;\n  const to = ctx !== '' ? `${ctx}.${path}` : path;\n  return () => Show({\n    when: exact ? route().name === to : route().name.startsWith(to),\n    fallback: () => props.fallback,\n    children: MatchContext.Provider({\n      value: to,\n      children: () => props.children,\n    }),\n  });\n}\n","import { UnionToIntersection } from 'ts-essentials';\nimport { Switch, createState, createEffect, createMemo } from 'solid-js';\nimport { useRoute } from '../context';\nimport { MatchRoute } from './MatchRoute';\n\n/** A tree of route path segments */\nexport type RenderTreeOf<Tree> =\n  Owned<Tree> | RenderNode &\n  UnionToIntersection<\n    Tree extends readonly (infer Node)[]\n    ? Node extends { name: infer Name, children?: infer Children }\n      ? Name extends (string | number | symbol)\n        ? Children extends {}\n          ? { [K in Name]?: RenderTreeOf<Children> }\n          : { [K in Name]?: Owned<Children> | RenderNode }\n        : never\n      : never\n    : never\n  >;\n\nexport interface RenderNode {\n  render?(props: { children: JSX.Element }): JSX.Element,\n  fallback?(props: { children: JSX.Element }): JSX.Element,\n};\n\nexport type OwnedBy<Tree, Props> =\n  UnionToIntersection<\n    Tree extends readonly (infer Node)[]\n    ? Node extends { name: infer Name, children?: infer Children }\n      ? Name extends (string | number | symbol)\n        ? Children extends {}\n          ? { [K in Name]?: GetProps<Props> & OwnedBy<Children, Props> }\n          : { [K in Name]?: GetProps<Props> }\n        : never\n      : never\n    : never\n  >;\n\nexport interface OwnedOps<Tree, Props> {\n  render: (props: Props) => JSX.Element,\n\n  /**\n   * Default prop values for when no matches are found. Props that are optional\n   * should be typed as such within `Props` itself.\n   */\n  defaultProps: Props,\n\n  /**\n   * A tree of route paths and prop getters. A prop getter is a function of type\n   * `() => PropValue`. The key of the getter determines what prop it gets, and\n   * the type of that prop.\n   *\n   * The tree can go as deep as `Tree` will allow for, with each non-function\n   * key corresponding to a path segment in a route.\n   */\n  props: OwnedBy<Tree, Props>,\n}\n\n/** Existential wrapper around `OwnedOps` that hides the inner `Tree` and\n * `Props` types */\nexport type Owned<Tree> =\n  <R>(cont: <Props>(self: OwnedOps<Tree, Props>) => R) => R;\n\n/** Turn an object into the same object, but all its properties are optional and\n * made into functions returning their value */\nexport type GetProps<Props> =\n  { [K in keyof Props]?: () => Props[K] };\n\n/**\n * Helper function. Use this as a `render` function to just render the children\n * only.\n */\nexport function passthru<T>(props: { children: T }): T {\n  return props.children;\n}\n\nexport default function RouteStateMachine<R extends RenderTreeLike>(tree: R): JSX.Element {\n  const route = useRoute();\n\n  function traverseHydrate<Props>(\n    path0: string[],\n    node0: GetPropsLike<Props>,\n    render: (props: Props) => JSX.Element,\n    defaultProps: Props,\n  ): JSX.Element {\n    const [state, setState] = createState(defaultProps);\n\n    function populate(\n      path: string[],\n      node: GetPropsLike<Props>,\n      next: Partial<Props>,\n      count: number,\n    ): number {\n      console.log('populate visit', path, node, next);\n\n      for (const key in node) {\n        const gp = (node as GetProps<Props>)[key as keyof Props];\n        if (typeof gp === 'function') {\n          const value = gp();\n          next[key as keyof Props] = value;\n          count ++;\n          continue;\n        }\n        if (gp !== undefined) {\n          if (path[0] === key) {\n            return populate(path.slice(1), gp as any, next, count);\n          }\n        }\n      }\n      return count;\n    }\n\n    const getPathSuffix = createMemo<[string, string[]]>(() => {\n      const name = route().name;\n      const p = name.split('.');\n      p.splice(0, path0.length);\n      return [name, p];\n    }, undefined, (a, b) => a && a[0] === b[0]);\n\n    createEffect(() => {\n      const next: Partial<Props> = {};\n      if (populate(getPathSuffix()[1], node0, next, 0) > 0) {\n        setState(next);\n      }\n    });\n\n    return render(state as Props);\n  }\n\n  function traverse(\n    path: string[],\n    node: RenderTreeLike,\n  ): JSX.Element {\n    if (typeof node === 'function') {\n      return node(function <Props>(owned: OwnedOpsLike<Props>) {\n        const { props, render, defaultProps } = owned;\n        return traverseHydrate(path, props, render, defaultProps);\n      });\n    }\n\n    const children: JSX.Element = [];\n    let { render: Render, fallback, ...routes } = node;\n    if (Render === undefined) { Render = passthru; }\n    if (typeof Render !== 'function') { return undefined; }\n    for (const key in routes) {\n      const next = [...path, key];\n      const child = (routes as any)[key];\n      console.log('visit', path, key, next, child);\n      children.push(MatchRoute({\n        prefix: key,\n        children: () => traverse(next, child),\n      }));\n    }\n\n    return Render({\n      children: Switch({\n        fallback: typeof fallback === 'function' ? fallback({ children }) : undefined,\n        children,\n      }),\n    });\n  }\n\n  console.log(tree);\n\n  return traverse([], tree);\n}\n\n/**\n * Monomorphic-ish version of 'GetProps'\n */\ntype GetPropsLike<Props> =\n  { [k: string]: GetPropsLike<Props> } & GetProps<Props>;\n\n/**\n * Monomorphic-ish version of 'OwnedOps'\n */\ninterface OwnedOpsLike<Props> {\n  render: (props: Props) => JSX.Element,\n  defaultProps: Props,\n  props: GetPropsLike<Props>\n}\n\n/**\n * Monomorphic-ish version of 'Owned'\n */\ntype OwnedLike =\n  (cont: <Props>(self: OwnedOpsLike<Props>) => any) => any;\n\n/**\n * Monomorphic-ish version of 'RenderTreeOf'\n */\nexport type RenderTreeLike\n  = OwnedLike\n  | (RenderNode & { [k: string]: RenderTreeLike });\n","import { State as RouteState, Router as Router5, Route } from 'router5';\nimport { createSignal, createEffect, createMemo } from 'solid-js';\n\nimport { SharedRouterValue, RoutesLike } from './types';\nimport Context from './context';\nimport createLink, { LinkProps, RouteNameOf } from './components/Link';\nimport RouteStateMachine, { RenderTreeOf, RenderTreeLike } from './components/RouteTree';\nimport { DefaultDependencies } from 'router5/dist/types/router';\n\nexport { LinkNav } from './components/Link';\nexport { MatchRoute, ShowRoute } from './components/MatchRoute';\nexport { passthru } from './components/RouteTree';\nexport { useRoute, useRouteName, useActive, isActive } from './context';\n\nexport type { MatchRouteProps, ShowRouteProps } from './components/MatchRoute';\nexport type { LinkProps, RouteNameOf } from './components/Link';\nexport type { RenderTreeOf } from './components/RouteTree';\nexport type { RoutesLike, SharedRouterValue, RouterContextValue } from './types';\n\n/**\n * Create a router for use in solid-js.\n *\n * I'd recommend putting your router in its own file like './router.ts', then\n * exporting the results of this function, like\n *\n * ```ts\n * import { createRouter, Router as Router5 } from 'router5';\n * import { createSolidRouter } from 'solid-ts-router';\n *\n * const routes = [\n *   ...\n * ] as const;\n *\n * // note the \"as const\" is very important! this causes TypeScript to infer\n * // `routes` as the narrowest possible type.\n *\n * function performInitialRedirect(router: Router5) {\n *   ...\n * }\n *\n * export const { Provider, Link, Router } = createSolidRouter(routes, routes => {\n *   return createRouter(routes, {...router5OptionsHere});\n * }, performInitialRedirect);\n * ```\n */\nexport default function createSolidRouter<Routes extends RoutesLike<Deps>, Deps = DefaultDependencies>(\n  routes: Routes,\n  createRouter5: (routes: Route<Deps>[]) => Router5<Deps>,\n  onStart?: (router: Router5<Deps>) => void,\n): {\n  Provider(props: { children: JSX.Element }): JSX.Element,\n  Link(props: LinkProps<RouteNameOf<Routes>>): JSX.Element,\n  Router(props: { children: RenderTreeOf<Routes> }): JSX.Element,\n  router: SharedRouterValue<Deps, Routes>,\n  hints: Phantom<{\n    routes: Routes,\n    name: RouteNameOf<Routes>,\n    tree: RenderTreeOf<Routes>\n  }>,\n} {\n  const router5: Router5<Deps> = createRouter5(routes as any as Route<Deps>[]);\n  // yolo, hopefully router5 doesn't actually mutate routes =)\n\n  const self: SharedRouterValue<Deps, Routes> = { routes, router5 };\n  Object.freeze(self);\n\n  return {\n    Link: createLink(self),\n\n    Router(props: { children: RenderTreeOf<Routes> }): JSX.Element {\n      return RouteStateMachine(props.children as RenderTreeLike);\n    },\n\n    Provider(props: { children: JSX.Element }): JSX.Element {\n      const initialState = router5.getState() ?? { name: '' };\n      const [getRoute, setRoute] = createSignal<RouteState>(initialState);\n\n      // create a signal for just the name as a `string` since strings are very\n      // easy to compare by `===`\n      const [getRouteName, setRouteName] = createSignal<string>(initialState.name, (a, b) => a === b);\n      const getSplitRouteName = createMemo<string[]>(\n        () => getRouteName().split('.'),\n        initialState.name.split('.'),\n      );\n\n      const value = {\n        getRoute,\n        getRouteName: getSplitRouteName,\n        router: self as SharedRouterValue<unknown, unknown>,\n      };\n\n      createEffect(() => {\n        router5.subscribe((state) => {\n          setRoute(state.route);\n          setRouteName(state.route.name);\n        });\n        router5.start();\n        if (typeof onStart === 'function') onStart(router5);\n      });\n\n      return (\n        <Context.Provider value={value}>\n          {props.children}\n        </Context.Provider>);\n    },\n    router: self,\n    hints: {} as any,\n  };\n}\n\nexport type Phantom<T> = { __phantom__: never } & T;\n"],"names":["Context","createContext","useRoute","useContext","getRoute","useRouteName","getRouteName","useActive","link","isActive","here","l","i","length","seg","slice","LinkNav","renderRouteLike","route","join","defaultLinkConfig","navActiveClassName","createLink","self","config","router5","props","getClassList","createMemo","classList","type","undefined","nav","to","getInnerProps","_cl","onClick","_oc","innerProps","disabled","ev","preventDefault","navigate","params","Back","window","history","back","target","blur","buildPath","MatchContext","MatchRoute","ctx","path","prefix","exact","Match","when","name","startsWith","children","Provider","value","ShowRoute","Show","fallback","passthru","RouteStateMachine","tree","traverseHydrate","path0","node0","render","defaultProps","state","setState","createState","populate","node","next","count","console","log","key","gp","getPathSuffix","p","split","splice","a","b","createEffect","traverse","owned","Render","routes","child","push","Switch","createSolidRouter","createRouter5","onStart","Object","freeze","Link","Router","initialState","getState","setRoute","createSignal","setRouteName","getSplitRouteName","router","subscribe","start","hints"],"mappings":"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"}